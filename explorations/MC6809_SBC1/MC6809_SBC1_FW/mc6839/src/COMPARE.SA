 NAM COMPARE
 TTL FLOATING PT. COMPARE FUNCTION
*
* LINKING LOADER DEFINITIONS
*
 XDEF  MAGCMP,INFAR2,INFAR1,CMPINF,NANCMP
 XDEF  CMPZER,ARG1UN,ARG2UN,BOTHUN
*
 XREF  SNORM,LNORM,ENORM,ROUND,IOPSET
*
* REVISION HISTORY:
*   DATE	PROGRAMMER     REASON
*
*  23.MAY.80	G. STEVENS     ORIGINAL
*  01.JUL.80	G. STEVENS     FIX CMP. STEP2 SO THAT IT
*			       DOESN'T BOMB THE CCR.
*  07.JUL.80	G. STEVENS     ADD ROUTINES FOR UNNORMALIZED
*  14.AUG.80	G. STEVENS     CHANGE CONDITIONS FOR ERRUN
*  19.AUG.80	G. STEVENS     ADD CODE TO HANDLE UNORMAL ZEROS
*  22.AUG.80	G. STEVENS     PREDICATE CMP'S SET UNORDERED PROPERLY     RDERED PROPER
*
 PAG
*
*
* HERE IS THE FUNCTION COMPARE AND ITS
* SUPPORT ROUTINES. AS WITH MOST OF THE
* OTHER FUNCTIONS, COMPARE MAKES USE OF
* A TABLE TO CALL ONE OF SEVERAL PROCEDURES
* DEPENDING ON THE TYPE OF THE INPUT OPERANDS.
* EACH OF THESE SUB PROCEDURES PERFORMS THE
* OPERATION AND THEN CALLS A GENERAL
* PROCEDURE TO DO THE FINAL ACTION OF
* EITHER RETURNING CONDITION CODES SET
* TO THE RESULT OF THE COMPARE OR
* AFFIRMING/DISAFFIRMING A SET OF INPUT
* PREDICATES.
*
*
* LOCAL EQUATES
*
* PREDICATE BIT EQUATES
*
UN EQU	BIT0
LT EQU	BIT1
EQ EQU	BIT2
GT EQU	BIT3
NE EQU	BIT4
GE EQU	BIT3+BIT2
LE EQU	BIT1+BIT2
*
*
* CONDITION CODE EQUATES
*
CCGT EQU  00
CCLT EQU  N
CCEQ EQU  Z
CCUN EQU  C
*
NCCGT EQU  N+Z+V+C
NCCLT EQU  Z+V+C
NCCEQ EQU  N+V+C
NCCUN EQU  N+Z+V
*
*******************************************************************
*
* PROCEDURE A:
*
* NON SPECIAL CASE COMPARE
*
* PROCEDURE MAGCMP
*
*   MAGCMP DOES THE NON-SPECIAL CASE COMPARES
* IT FIST LOOKS AT THE SIGNS OF THE OPERANDS
* TO SEE IF THEY TELL THE STORY, AND THEN, IF
* NECESSARY COMPARES THE MAGNITUDES OF ARG1
* ARG2.
*
* CHECK THE SIGNS OF THE ARGUMENTS
*
MAGCMP LDA  ARG1,U	 SIGN ARG1
 EORA  ARG2,U		 SIGN ARG2
 IFCC LT	       SIGNS NOT THE SAME
   LDA	ARG1,U
   IFCC  LT	       ARG1 NEGATIVE
     LDB  #BIT1        SET  <
*
   ELSE
     LDB  #BIT3        SET  >
*
   ENDIF
*
* ELSE IF THE SIGNS ARE THE SAME WILL
* HAVE TO DO A MAGNITUDE ON ARG1 AND ARG2
*
 ELSE L 	       SIGN ARE SAME
   LDD	EXP1,U
   CMPD  EXP2,U        COMPARE EXPONENTS
   IFCC  NE	     EXPONENTS UNEQUAL
     PSHS  CC	       SAVE CC REG.
     LDA  ARG1,U	CHECK SIGN
*
* IF THE SIGN OF THE ARGUMENTS IS POSITIVE
* THEN ASSIGN PREDICATES AS THE CONDITION
* CODES INDICATE.
*
     IFCC  GE	   SIGN BOTH POSITIVE
       PULS  CC      GET ORIGINAL CC INFO
       IFCC   GT
	 LDB  #BIT3	SET  >
*
       ELSE
	 LDB  #BIT1	SET  <
*
       ENDIF
*
* ELSE IF SIGNS ORIGINALLY BOTH NEGATIVE
* THEN CODITION CODES ARE OPPOSITE.
*
     ELSE	    SIGNS BOTH NEGATIVE
       PULS  CC       GET OSIGINAL CC INFO
       IFCC  GT
	 LDB  #BIT1	SET  <
*
       ELSE
	 LDB  #BIT3	SET  >
*
       ENDIF
*
     ENDIF	     SIGNS POSITIVE
*
   ELSE 	     EXPONENTS EQUAL
*
* SET UP THE COMPARE
*
     LEAX  FRACT1,U
     LEAY  FRACT2,U
     CLRB
     LDA  B,X	  INITIALIZE A REG.
*
* COMPARE MAGNITUDES
*
     WHILE  A,EQ,(B,Y)
       IF  B,GE,#(ARGSIZ-4)
	 BRA  AREQU
       ENDIF
       INCB
       LDA  B,X
     ENDWH
*
*
AREQU EQU  *
*
     PSHS  CC	     SAVE CC REG.
*
* BASED ON THE CONDITION CODES AND SIGN
* OF THE ARGUMENTS, GET PREDICATE BITS.
*
* IF B CONTAINS ( ARGSIZ-4 ) THE N THE
* ARE EQUAL.
*
     IF  B,GE,#(ARGSIZ-4)
       LDB  #BIT2     SET =
       LEAS  1,S      RESTORE STACK
*
     ELSE
       LDA  ARG1,U	  CHECK SIGN
*
* IF THE SIGN OF THE ARGUMENTS IS POSITIVE
* THEN ASSIGN PREDICATES AS THE CONDITION
* CODES INDICATE.
*
       IFCC  GE      SIGN BOTH POSITIVE
	 PULS  CC      GET ORIGINAL CC INFO
	 IFCC	CC	  ARG1 >  ARG2
	   LDB	#BIT3	  SET  >
*
	 ELSE
	   LDB	#BIT1	  SET  <
*
	 ENDIF
*
* ELSE IF SIGNS ORIGINALLY BOTH NEGATIVE
* THEN CODITION CODES ARE OPPOSITE.
*
       ELSE	      SIGNS BOTH NEGATIVE
	 PULS  CC	GET OSIGINAL CC INFO
	 IFCC  CC	   ARG1 < ARG2
	   LDB	#BIT1	  SET  <
*
	 ELSE
	   LDB	#BIT3	  SET  >
*
	 ENDIF
*
       ENDIF	       SIGNS POSITIVE
*
     ENDIF	     SIGNIFICANDS EQUAL
*
   ENDIF	    EXPONENTS EQUAL
*
 ENDIF		    SIGNS NOT THE SAME
*
* PROCEED TO STEP II TO EITHER SET CCR
* OR AFFIRM/DISAFFIRM A PREDICATE.
*
 LBSR  CMPST2
*
*
*
 RTS	   RETURN
*
*
*
 PAG
*
******************************************************************
*
* PROCEDURE B:
*
* INFINITY AS ARG2 AND ARG1 <> NAN OR INFINITY
*
*
* PROCEDURE  INFAR2
*
*   INFAR2 HANDLES THE CASE WHRER ARG2 IS
* INFINITY AND ARG1 IS NOT EITHER A NAN OR
* INFINITY.
*
* CHECK CLOSURE MODE
*
INFAR2 LDA  [PFPCB,U]
 LSRA		 CLOSURE MODE BIT
 IFCC  CS	AFFINE MODE
   LDA	ARG2,U
*
* IF AFFINE MODE AND ARG2 = PLUS INFINITY
* THEN SIGNAL ARG1 > ARG2.
*
   IFCC  GE	    ARG2 = PLUS INFINITY
     LDB  #BIT1     SET  <
*
* ELSE IF AFFINE MODE AND ARG2 = MINUS
* INFINITY THEN SIGNAL ARG1 > ARG2.
*
   ELSE
     LDB  #BIT3     SET  >
*
   ENDIF
*
* ELSE IF IN PROJECTIVE MODE THEN SIGNAL
* UNORDERED.
*
 ELSE		PROJECTIVE
   LDB	#BIT0
*
 ENDIF
*
* PROCEED TO STEP II TO EITHER SET CCR
* OR AFFIRM/DISAFFIRM A PREDICATE.
*
 LBSR  CMPST2
*
 RTS  RETURN
*
*
*
 PAG
*
*******************************************************************
*
* PROCEDURE  C:
*
* INFINITY AS ARG1 AND ARG2 <> NAN OR INFINITY
*
*
* PROCEDURE  INFAR1
*
*    INFAR1 HANDLES THE CASE OF COMPARE WHERE
* ARG1 IS INFINITY AND ARG2 IS NOT EITHER A
* NAN OR INFINITY.
*
* CHECK CLOSURE MODE
*
INFAR1 LDA  [PFPCB,U]
 LSRA
 IFCC  CS	       AFFINE MODE
   LDA	ARG1,U
*
* IF IN AFFINE MODE AND ARG1 = PLUS INFINITY
* THEN SIGNAL ARG1 > ARG2.
*
   IFCC  GE
     LDB  #BIT3        SET  >
*
* ELSE IF IN AFFINE MODE AND ARG1 = MINUS
* INFINITY THEN SIGNAL ARG1 > ARG2.
*
   ELSE
     LDB  #BIT1        SET  <
*
   ENDIF
*
* ELSE IF IN PROJECTIVE MODE THEN SIGNAL UNORDERED
*
 ELSE		      PROJECTIVE MODE
   LDB	#BIT0
*
 ENDIF
*
* PROCEED TO STEP II TO EITHER SET CCR OR
* AFFIRM/DISAFFIRM A PREDICATE.
*
 BSR  CMPST2
*
*
 RTS	  RETURN
*
*
*
 PAG
*
*******************************************************************
*
* PROCEDURE E:
*
* ARG1 AND ARG2 ARE BOTH INFINITY
*
*
* PROCEDURE  CMPINF
*
*    CMPINF HANDLES THE CASE OF COMPARE WHERE
* BOTH ARG1 AND ARG2 ARE INFINITY.
*
* CHECK CLOSURE MODE
*
CMPINF LDA  [PFPCB,U]
 LSRA		CLOSURE MODE BIT
*
* IF IN PROJECTIVE MODE THEN SIGNAL ARG1 = ARG2
*
 IFCC  CC	  PROJECTIVE MODE
   LDB	#BIT2	  SET  =
*
* ELSE IN PROJECTIVE AND THE SIGNS OF THE
* ARGUMENTS ARE THE SAME THEN SIGNAL ARG1 = ARG2
*
 ELSE		  AFFINE MODE
   LDA	ARG1,U
   EORA  ARG2,U
   IFCC  GE	 SIGNS EQUAL
     LDB  #BIT2     SET  =
*
* ELSE IF SIGNS NOT THE SAME SET PREDICATE BITS
* ACCORDINGLY.
*
   ELSE
     LDA  ARG1,U
     IFCC  LT	     SIGN ARG1 IS NEG.
       LDB  #BIT1	SET  <
*
     ELSE	     SIGN ARG1 IS POS.
       LDB  #BIT3
*
     ENDIF
*
   ENDIF	 SIGNS EQUAL
*
 ENDIF		 PROJECTIVE MODE
*
* PROCEED YO STEP II TO EITHER SET CC REG.
* OR AFFIRM/DISAFFIRM A PREDICATE.
*
 BSR  CMPST2
*
*
 RTS  RETURN
*
*
*
 PAG
*
*******************************************************************
*
* PROCEDURE F:
*
* EITHER ARG1 OR ARG2 IS A NAN
*
*
* PROCEDURE NANCMP
*
*   NANCMP HANDLES A CMP WHERE EITHER ARG1 AND
* ARG2 IS A NAN.
*
NANCMP LDB  #BIT0   SET UNORDERED
*
* PROCEED TO STEP II TO EITHER SET CC REG. OR
* AFFIRM/DISAFFIRM A PREDICATE.
*
 BSR  CMPST2
*
*
 RTS   RETURN
*
*
*
 PAG
*
****************************************************************
*
* PROCEDURE  G:
*
* BOTH ARG1 AND ARG2 ARE ZERO
*
*
* PROCEDURE CMPZER
*
*    CMPZER HANDLES THE CASE OF COMPARE WHERE
* BOTH ARG1 AND ARG2 ARE ZERO.
*
CMPZER LDB  #BIT2  SET =
*
* PROCEED TO STEP II TO EITHER SET CC REG.
* SO AFFIRM/DISAFFIRM A PREDICATE.
*
 BSR  CMPST2
*
 RTS	RETURN
*
*
*
 PAG
*
****************************************************************
*
* PROCEDURE H:
*
*  ARG1 UNORMALIZED & ARG2 NORMALIZED
*
* PROCCEDURE  ARG1UN
*
*    ARGIUN HANDLES THE CASE OF COMPARE WHERE ARG1 IS
* UNORMALIZED. ARG1 IS NORMALIZED AS FAR AS THE LOWER BOUND ON THE
* EXPONENT ALLOWS.
*
*  ON ENTRY: U - STACK FRAME POINTER
*
*  ON EXIT:
*  IN PREDICATE COMPARES:
*	LOCATION CCREG ON THE STACCK FRAME CONTAINS THE
*  CONDITION ODES AS SET BY THE COMPARE.
*
*  IN PREDICATE COMPARES:
*	THE FIRST BYTE OF THE RESULTS FRACTION CONTAINS
*  TRUE($00) OR FALSE($FF) DEPENDING ON WHETHER THE
* PREDICATE WAS AFFIRMED OR DISAFFIRMED.
*
*	U - UNCHANGED
*	X,Y,D,CC - DESTROYED
*
ARG1UN EQU  *
*
* CHOOSE ARG1
*
 LEAX  ARG1,U
*
* NORMALIZE OPERAND AND PERFORM THE COMPARE AS WITH TWO NORMALIZED
* OPERANDS
*
 BSR  NRMCMP
*
*
 RTS		      RETURN
*
 PAGE
*
****************************************************************
*
* PROCEDURE I:
*
*  ARG2 UNORMALIZED & ARG1 NORMALIZED
*
* PROCCEDURE  ARG2UN
*
*    ARGIUN HANDLES THE CASE OF COMPARE WHERE ARG1 IS
* UNORMALIZED. ARG1 IS NORMALIZED AS FAR AS THE LOWER BOUND ON THE
* EXPONENT ALLOWS.
*
*  ON ENTRY: U - STACK FRAME POINTER
*
*  ON EXIT:
*  IN PREDICATE COMPARES:
*	LOCATION CCREG ON THE STACCK FRAME CONTAINS THE
*  CONDITION ODES AS SET BY THE COMPARE.
*
*  IN PREDICATE COMPARES:
*	THE FIRST BYTE OF THE RESULTS FRACTION CONTAINS
*  TRUE($00) OR FALSE($FF) DEPENDING ON WHETHER THE
* PREDICATE WAS AFFIRMED OR DISAFFIRMED.
*
*	U - UNCHANGED
*	X,Y,D,CC - DESTROYED
*
ARG2UN EQU  *
*
* CHOOSE ARG2
*
 LEAX  ARG2,U
*
* NORMALIZE OPERAND AND PERFORM THE COMPARE AS WITH TWO NORMALIZED
* OPERANDS
*
 BSR  NRMCMP
*
*
 RTS		      RETURN
*
 PAGE
****************************************************************
*
* PROCEDURE J:
*
*  ARG2 UNNORMALIZED & ARG1 UNNORMALIZED
*
* PROCCEDURE  BOTHUN
*
*     BOTHUN HANDLES THE CASE OF COMPARE WHERE BOTH
* ARG1 AND ARG2 ARE UNNORMALIZED. BOTH ARGUMENTS
* ARE NORMALIZED AS FAR AS THE LOWER BOUND ON THE EXPONENT
* ALLOWS.
*
*  ON ENTRY: U - STACK FRAME POINTER
*
*  ON EXIT:
*  IN PREDICATE COMPARES:
*	LOCATION CCREG ON THE STACCK FRAME CONTAINS THE
*  CONDITION ODES AS SET BY THE COMPARE.
*
*  IN PREDICATE COMPARES:
*	THE FIRST BYTE OF THE RESULTS FRACTION CONTAINS
*  TRUE($00) OR FALSE($FF) DEPENDING ON WHETHER THE
* PREDICATE WAS AFFIRMED OR DISAFFIRMED.
*
*	U - UNCHANGED
*	X,Y,D,CC - DESTROYED
*
BOTHUN EQU  *
*
* NORMALIZE ARG1 & ARG2
*
 LEAX  ARG1,U
 LBSR  LNORM
 LEAX  ARG2,U
*
* NORMALIZE OPERAND AND PERFORM THE COMPARE AS WITH TWO NORMALIZED
* OPERANDS
*
 BSR  NRMCMP
*
*
 RTS		      RETURN
*
 PAGE
*
*
* PROCEDURE  NRMCMP
*
*    PERFORMS A MAGNITUDE COMPARE WHEN ONE OF THE OPERANDS IS
* UNNORMALIZED.
*
* ON ENTRY: X - POINTS TO THE UNORMALIZED OPERAND
*	    ARG1 AND ARG2 CONTAIN THE INPUT OPERANDS
*
* ON EXIT: EITHER THE CONDITION CODES HAVE BEEN SET OR THE
*	   PREDICATES AFFIRMED/DISAFIRMED DEPENDING ON
*	   WHETHER OR NOT THE COMPARE IS A NON- PREDICATE
*	   OR PREDICATE COMPARE.
*
NRMCMP EQU  *
*
* NORMALIZE THE UNNORMALIZED ARGUMENT.
*
 LBSR  LNORM
*
* CHECK FOR BOTH ARGUMENTS BEING ZERO
*
 LDA  TYPE1,U
 ADDA  TYPE2,U
 IF  A,EQ,#04	   BOTH ARGUMENTS ZERO
   BSR	CMPZER
*
* PREFORM COMPARE AS WITH 2 NORMALIZED OPERANDS.
*
 ELSE
   LBSR  MAGCMP
*
 ENDIF
*
 RTS		   RETURN
*
 PAGE
*
*
*******************************************************************
*
* COMPARE STEP II
*
* PROCEDURE CMPST2
*
*   CMPST2 DECIDES WHETHER THE COMPARE IS
* A PREDICATE OR NON-PREDICATE COMPARE AND
* EITHER SETS UP THE CONDITION CODES OR
* RETURNS TRUE/FALSE DEPENDING ON THE INPUT
* PREDICATES.
*
*
*
* FIRST SEE IF COMPARE IS A NON-PREDICATE OR
* PREDICATE COMPARE
*
CMPST2 LDA  FUNCT,U	FUNCTION CODE
*
* IF THE COMPARE IS A PREDICATE COMPARE THEN
* JUMP OVER THE CODE THAT HANDLES NON-PREDICATE
* COMPARES
*
 IF  A,EQ,#FCPCMP
   BRA	PCMP
*
 ELSE
 IF  A,EQ,#FCTPCM
   BRA	PCMP
*
 ENDIF
 ENDIF
*
*
*  B E G I N   NON-PREDICATE HANDLER
*
*
* CASE( PREDICATE BITS ) TO SEE WHICH
* CC BIT TO SET.
*
    LDA  CCREG,U		    GET CALLER'S CC REG
    ANDA #$F0			    AND OUT PREVIOUS CONDITIONS
*				    BUT SAVE E,F,H AND I BITS
*
* CASE OF EQUAL
*
   IF  B,EQ,#EQ
     ORA  #CCEQ
*
* CASE OF LT
*
   ELSE
     IF  B,EQ,#LT
       ORA  #CCLT
*
*   CASE OF UNORDERED
*
     ELSE
       IF  B,EQ,#UN
	 ORA  #CCUN
	   LDB	#ERRUN	    UNOR BIT
	   ORB	TSTAT,U
	   STB	TSTAT,U
      ENDIF [UNORDERED]
    ENDIF [LESS THAN]
*   IF CASE WAS > THEN ALL BITS = 0 (WHICH WAS THE INITIAL CONDITION)
  ENDIF     CASE( PREDICATE BITS )
    STA  CCREG,U	 STORE MODIFIED CC'S
*
*
*  E N D  NON-PREDICATE HANDLER
*
*
*
* BRANCH TO RETURN
*
 BRA RET
*
*
*
*  B E G I N  PREDICATE HANDLER
*
* ELSE IF THE COMPARE IS A PREDICATE COMPARE
* THEN CHECK THE PREDICATE BITS AGAINST OF THE
* COMPARE AND RETURN EITHER TRUE OR FALSE
*
PCMP EQU  *
*
*
* CHECK PREDICATES AND SET THE NE BIT PROPERLY
*
   PSHS  B    SAVE B ON STACK
   ANDB  #EQ	     CHECK EQUAL
   IFCC  EQ	     NOT EQUAL
     LDB  0,S
     ORB  #NE	     SET NOT EQUAL
     STB  0,S
*
   ENDIF
*
   ANDB  TPARAM,U     CHECK PREDICATES
*
* IF PREDICATE TRUE THEN PUT $00 IN THE
* FIRST BYTE OF THE FRACTION; OTHERWISE
* IF PREDICATE IS FALSE, STORE $FF.
*
   IFCC  NE	   PREDICATE TRUE
     CLR  FRACTR,U
*
   ELSE 	PREDICATE FALSE
     LDA  #$FF
     STA  FRACTR,U
*
   ENDIF
*
* IF UNORDERED IS AFFIRMED THEN SET THE UNORDERED
* FLAG IN THE STATUS BYTE; ADDITIONALLY IF THE
* PREDICATE IS <> THEN SET THE RESULT TO TRUE
* TO GIVE THE USER THE TEST FOR A NAN I.E. IF
* A <> A RETURNS TRUE THEN 'A' IS A NAN.
*
   PULS  A
   ANDA  #BIT0	     CHECK UNORDERED
   IFCC  NE	     UNORDERED AFFIRMED
       LDA  TSTAT,U	   SET UNORDERED FLAG
       ORA  #ERRUN
       STA  TSTAT,U
*
       LDA TPARAM,U
       IF  A,EQ,#NE	    PREDICATE IS <>
	 CLR  FRACTR,U	    SET RESULT TRUE
*
       ELSE
	 IF  A,NE,#EQ
	   IF  A,NE,#UN
	     LDA  #06		IOP CODE
	     LBSR IOPSET
*
	   ENDIF
	 ENDIF
       ENDIF
*
*
   ENDIF	  UNORDERED
*
*
*  E N D   PREDICATE HANDLER
*
*
*
RET RTS    RETURN
*
*
*
 PAG
*
*

 TTL '6809 FLOATING POINT PACKAGE - COPYRIGHT (C) MOTOROLA 1980'
 OPT LLEN=120,NOG
* TTL **** 6809 FLOATING POINT - COPYRIGHT(C) MOTOROLA 1980

*
***********************************************************************
*
*    G L O B A L  E Q U A T E S
*
*	 THESE ARE THE GLOBAL EQUATES FOR THE 6809 FP PACKAGE
*
**********************************************************************
*
* BIT VALUES
*
BIT0 EQU 1
BIT1 EQU 2
BIT2 EQU 4
BIT3 EQU 8
BIT4 EQU 16
BIT5 EQU 32
BIT6 EQU 64
BIT7 EQU 128
BIT8 EQU 256
BIT9 EQU 512
BIT10 EQU 1024
BIT11 EQU 2048
BIT12 EQU 4096
BIT13 EQU 8192
BIT14 EQU 16384
BIT15 EQU 32768
*
* CONDITION CODE BITS
*   USED IN ORCC TO SET A CC BIT
*
N EQU BIT3
Z EQU BIT2
V EQU BIT1
C EQU BIT0
*
* CONDITION CODE BIT MASKS
*    USED IN ANDCC TO CLEAR SINGLE BITS
*
NN EQU $F7
NZ EQU $FB
NV EQU $FD
NC EQU $FE
 PAGE
*
*
*
*      STACK FRAME EQUATES
*
*
*			      INITIALIZED BY:
FUNCT EQU 0		     IREG/ISTACK
RPREC EQU FUNCT+1	     IXIT
TSTAT EQU RPREC+1	     IXIT (0)
TPARAM EQU TSTAT+2	     IXIT (0)
STIKY EQU TPARAM+2	     IXIT (0)
PTOS EQU STIKY+1	     UNDEFINED FOR REG CALLS; ISTACK (0)
PFPCB EQU PTOS+2	     IREG/ISTACK
RESULT EQU PFPCB+2	     SET BY OPERATIONS
SIGNR EQU RESULT
EXPR EQU RESULT+1
FRACTR EQU EXPR+2
TYPER EQU FRACTR+9
ARG2 EQU TYPER+1	     SET BY GETARG
SIGN2 EQU ARG2
EXP2 EQU ARG2+1
FRACT2 EQU EXP2+2
TYPE2 EQU FRACT2+9
ARG1 EQU TYPE2+1	     SET BY GETARG IF DYADIC
SIGN1 EQU ARG1
EXP1 EQU ARG1+1
FRACT1 EQU EXP1+2
TYPE1 EQU FRACT1+9	     IXIT (0); CHANGED BY GETARG IF DYADIC
ARGSIZ EQU TYPE2-ARG2+1
*
* STACK CALLS
ISTKPC EQU TYPE1+1	     USER'S REGISTERS, SAVED BY PSHS
CCREG EQU ISTKPC+2
DREG EQU CCREG+1
XREG EQU DREG+2
YREG EQU XREG+2
UREG EQU YREG+2
CALLPC EQU UREG+2
*
* REGISTER CALLS
IREGPC EQU TYPE1+1	     USER'S REGISTERS; SAVED BY PSHS
PFPCB2 EQU IREGPC+3
PRESUL EQU PFPCB2+2
PARG2 EQU PRESUL+2
PARG1 EQU PARG2+2
*
* TOTAL SIZE OF STACK FRAME
STKSIZ EQU CALLPC+2-FUNCT
*
* SIZE OF STACK FRAME FROM IREG OR ISTACK TO BOTTOM
*
FRMSIZ EQU ISTKPC-FUNCT
*
*
* SIZE OF CALLERS REGS (EXCEPT PC)
*
SIZREG EQU CALLPC-CCREG
*
* OFFSETS FOR INDIVIDUAL ARGUMENTS ON STACK FRAME
*
SIGN EQU 0
EXP EQU SIGN+1
FRACT EQU EXP+2
TYPE EQU FRACT+9
*
* ALIASES FOR SOME STACK FRAME ENTRIES
*
P    EQU  TPARAM+1	     EQUATE USED IN DECBIN
K    EQU  TPARAM+1	     EQUATE USED IN BINDEC
 PAGE
*
*  ARGUMENT TYPES
*
TYNORM EQU 0
TYZERO EQU 2
TYINF EQU 4
TYNAN EQU 6
TYNNRM EQU 8
*
* EXPONENT BIASES
SBIAS EQU 127 SINGLE PRECISION BIAS
DBIAS EQU 1023 DOUBLE PRECISION BIAS
*
* MISCELLANEOUS EQUATES
*
BIGIOP EQU 17 MAXIMUM LEGAL IOP NUMBER
 PAGE
*
*
*   FPCB REGISTER BYTE EQUATES
*
*
* FPCB REGISTER EQUATES
*
CTL EQU 0 CONTROL REG
ENB EQU 1 ENABLE BYTE
ERR EQU 2 ERROR STATUS BYTE
SS  EQU 3 SECONDARY STATUS
* OFFSET OF ADDRESS TO JUMP TO FOR TRAP
TRAPV EQU 4  TRAP VECTOR
*
*
*
* CONTROL BYTE
*
CTLAFF EQU BIT0 AFFINE/PROJECTIVE FLAG
CTLRND EQU BIT1+BIT2 ROUNDING MODE
CTLNRM EQU BIT3 NORMALIZE FLAG
CTLSIZ EQU BIT5+BIT6+BIT7

*
* ERROR STATUS BYTE
*
ERRIOP EQU BIT0 IOP ERROR
ERROVF EQU BIT1 OVERFLOW ERROR
ERRUNF EQU BIT2 UNDERFLOW ERROR
ERRDZ EQU BIT3 DIVIDE BY ZERO ERROR
ERRUN EQU BIT4 UNORDERED COMPARE ERROR
ERRIOV EQU BIT5 INTEGER OVERFLOW ERROR
ERRINX EQU BIT6 INEXACT ERROR
*
* TRAP ENABLE BYTE
*
ENBIOP EQU BIT0 INVALID OPERATION
ENBOVF EQU BIT1 OVERFLOW
ENBUNF EQU BIT2 UNDERFLOW
ENBDZ EQU BIT3 DIVIDE BY ZERO
ENBUN EQU BIT4 UNORDERED
ENBIOV EQU BIT5 INTEGER OVERFLOW
ENBINX EQU BIT6 INEXACT
*
* PRECISION MODES IN CONTROL BYTE
*
PRSIN EQU  00		    SINGLE
PRDBL EQU  BIT5 	    DOUBLE
PREXT EQU  BIT6 	    EXTENDED
PREFS EQU  BIT5+BIT6	    EXTENDED FORCE TO SINGLE
PREFD EQU  BIT7 	    EXTENDED FORCED TO DOUBLE
*
* ROUNDING MODES IN CONTROL BYTE
*
*
RN EQU	00	  ROUND TO NEAREST
RZ EQU	BIT1	  ROUND TO ZERO
RP EQU	BIT2	  ROUND TO PLUS INFINITY
RM EQU	BIT2+BIT1 ROUND TO MINUS INFINITY
*
* PRECISION INDEXES IN RPREC
*
SIN EQU  00
DBL EQU  02
EXT EQU  04
EFS EQU  06
EFD EQU  08
*
* SECONDARY STATUS  BYTE
*
SSIOP EQU BIT0+BIT1+BIT2+BIT3+BIT4
 PAGE
*
*
*     FUNCTION CODE EQUATES
*
*     BIT 7 = 1 = MIXED SIZE ARGUMENTS (MOV,CMP)
*     BIT 6 = 1 = TRAP ON UNORDERED COMPARE
*     BIT5-BIT0 = FUNCTION NUMBER
*
*
MIXED EQU BIT7
TONUN EQU BIT6		    TRAP ON UNORDERED
*
*
FCADD EQU 0
FCSUB EQU FCADD+2
FCMUL EQU FCSUB+2
FCDIV EQU FCMUL+2
FCREM EQU FCDIV+2
FCCMP EQU FCREM+2+MIXED
FCTCMP EQU FCREM+4+MIXED+TONUN
FCPCMP EQU FCREM+6+MIXED
FCTPCM EQU FCREM+8+MIXED+TONUN
FCSQRT EQU FCREM+10
FCINT EQU FCSQRT+2
FCFIXS EQU FCINT+2
FCFIXD EQU FCFIXS+2
FCMOV EQU FCFIXD+2+MIXED
FCBNDC EQU FCFIXD+4
FCAB EQU FCBNDC+2
FCNEG EQU FCAB+2
*
*    THE FOLLOWING OPCODES DO NOT GO THROUGH
*  A JUMP-ADDRESS TABLE.
*	NOTE: THE 'FCAB' AND 'FCNEG' WILL
*  NOT EVEN GO THROUGH THE DISPATCH ROUTINE.
*
FCNOJP EQU  FCNEG+2   MARKS OPCODES WITHOUT TABLES
*
FCDCBN EQU FCNOJP
FCFLTS EQU FCDCBN+2
FCFLTD EQU FCFLTS+2
*
*
* EXPONENT EQUATES
*
* MAXIMUM EXPONENTS
*
SMAXEX EQU $0080  SINGLE
DMAXEX EQU $0400  DOUBLE
EMAXEX EQU $4000  EXTENDED
*
* MINIMUM EXPONENTS
*
SMINEX EQU $FF81  SINGLE
DMINEX EQU $FC01  DOUBLE
EMINEX EQU $C001  EXTENDED
*
INFEX  EQU $7FFF  INFINITE EXPONENT
*
*
 PAGE
*
**************************************************************
*
*
*     G L O B A L   M A C R O S
*
*
**************************************************************
*
****************
*
* SRD
*   MACRO TO LOGICAL DOUBLE SHIFT D-REG N BITS RIGHT. (1 <= N <= 8)
*
*   CALL:  SRD N
*
SRD MACR
 IFGT (\0)-8 LOOK FOR ILLEGAL CASES
 FAIL *** SRD N; N <= 8 ***
 ENDC
 IFLT (\0)-1
 FAIL *** SRD N; N >= 0 ***
 ENDC
* N IS OKAY; DO THE SHIFTS
 IFEQ (\0)-8
 LSRA
 RORB
 ENDC
 IFGE (\0)-7
 LSRA
 RORB
 ENDC
 IFGE (\0)-6
 LSRA
 RORB
 ENDC
 IFGE (\0)-5
 LSRA
 RORB
 ENDC
 IFGE (\0)-4
 LSRA
 RORB
 ENDC
 IFGE (\0)-3
 LSRA
 RORB
 ENDC
 IFGE (\0)-2
 LSRA
 RORB
 ENDC
 IFGE (\0)-1
 LSRA
 RORB
 ENDC
 ENDM
 PAGE
*
*****************
*
* SLD N
*   MACRO TO LOGICALLY SHIFT D-REG N BITS OO
*   THE LEFT. (1 <= N <= 8)
*
*   CALL: SLD N
*
*****************
*
SLD MACR
* CATCH THE ILLEGAL CASES
 IFGT (\0)-8
 FAIL *** SSLD N; N <= 8 ***
 ENDC
 IFLT (\0)-1
 FAIL *** SLD N; N >= 0 ***
 ENDC
 IFEQ (\0)-8
 LSLB
 ROLA
 ENDC
 IFGE (\0)-7
 LSLB
 ROLA
 ENDC
 IFGE (\0)-6
 LSLB
 ROLA
 ENDC
 IFGE (\0)-5
 LSLB
 ROLA
 ENDC
 IFGE (\0)-4
 LSLB
 ROLA
 ENDC
 IFGE (\0)-3
 LSLB
 ROLA
 ENDC
 IFGE (\0)-2
 LSLB
 ROLA
 ENDC
 IFGE (\0)-1
 LSLB
 ROLA
 ENDC
 ENDM
 PAGE
*
*****************
*
* MOVE MACROS
*   THIS SET OF MACROS MOVES A SOURCE OPERAND TO
*   A DESTINATION OPERAND USING THE SPECIFIED
*   REGISTER AS INTERMEDIATE.
*
*   MOV<A|B|D|X|Y|U|S> <SOURCE>,<DEST>
*
*****************
*
MOVD MACR
     LDD \0
     STD \1
     ENDM
*
MOVA MACR
     LDA \0
     STA \1
     ENDM
*
MOVB MACR
     LDB \0
     STB \1
     ENDM
*
MOVX MACR
     LDX \0
     STX \1
     ENDM
*
MOVY MACR
     LDY \0
     STY \1
     ENDM
*
MOVU MACR
     LDU \0
     STU \1
     ENDM
*
MOVS MACR
     LDS \0
     STS \1
     ENDM
 PAGE
*
**********************************************
*
* BIT MANIPULATION MACROS
*   BSET  SET A BIT IN MEMORY
*   BCLR  CLEAR A BIT IN MEMORY
*
*   SET OR CLEAR A BIT IN MEMORY. THE FORMAT
*   OF THE CALL IS:
*    BSET<A|B> <BIT#>,<MEMORY LOCATION>
*    BCLR<A|B> <BIT#>,<MEMORY LOCATION>
*
*    THE A OR B REGISTER MUST BE SPECIFIED AND IT
*    PROVIDES THE INTERMEDIATE SCRATCH REGISTER.
*
*    THE BIT NUMBER CAN BE ONE OR MORE BITS
*
**********************
*
BSETA MACR
      LDA \1
      ORA #(\0)
      STA \1
      ENDM
*
BSETB MACR
      LDB \1
      ORB #(\0)
      STB \1
      ENDM
*
BCLRA MACR
      LDA \1
      ANDA #(-(\0)-1)!.$FF
      STA \1
      ENDM
*
BCLRB MACR
      LDB \1
      ANDB  ((-(\0)-1)!.$FF
      STB \1
      ENDM
 PAGE
*
***********************************************
*
*  INCREMENT AND DECREMENT 16 BIT REGISTESS
*
***********************************************
*
INCX MACR
 LEAX 1,X
 ENDM
*
DECX MACR
 LEAX -1,X
 ENDM
*
INCY MACR
 LEAY 1,Y
 ENDM
*
DECY MACR
 LEAY -1,Y
 ENDM
*
INCU MACR
 LEAU 1,U
 ENDM
*
DECU MACR
 LEAU -1,U
 ENDM
*
INCS MACR
 LEAS 1,S
 ENDM
*
DECS MACR
 LEAS -1,S
 ENDM
*
INCD MACR
 INCB
 BNE *+3
 INCA
 ENDM
*
DECD MACR
 TSTB
 BNE \.1
 DECA
\.1 DECB
 ENDM
*

 PAGE
*
******************
*
*  IOP N
*
*    MACRO TO SET INVALID OPERATION STATUS BITS IN
*    THE TEMPORARY STATUS BYTES ON THE STACK FRAME
*    SETS IOP BIT AND INVALID OPERATION CODE.
*
*  CALL: IOP N
*    WHERE N IS A VALID INVALID OPERATION NUMBER
*   USES A REGISTER
*
* USES A-REGISTER
*
*****************
*
IOP MACR
* CHECK FOR ILLEGAL CASES
 IFLT (\0)-1
 FAIL *** IOP N; N > 0 ***
 ENDC
 IFGT (\0)-BIGIOP
 FAIL *** IOP N; N TOO BIG ***
 ENDC
* NOT ILLEGAL
 LDA #(\0)
 STA TSTAT+1,U SET INVALID OPERATION NUMBER
 LDA TSTAT,U SET IOP BIT IN MAIN STATUS
 ORA #ERRIOP
 STA TSTAT,U
 ENDM
 PAGE
***********************************************************************
*
*	STRUCTURED MACROS FOR ASSEMBLY LANGUAGE PROGRAMMING THE 6809
*	BY JOEL BONEY
*	   GREG WALKER
*
EXBUG EQU $F000
STKTOP SET 0
ISLONG SET 0
PUSH MACR
***********************************************************************
*
*	PUSH --
*		THIS MACRO SIMULATES A 7-LEVEL STACK USING SEVEN SYMBOLS
*	WHOSE VALUES ARE REDEFINED TO BE THE VALUES ON THE STACK. THE
*	SYMBOL "STKTOP" CONTAINS A NUMBER FROM 0 TO 7 WHICH INDICATES
*	THE SYMBOL (S1 TO S7) THAT CONTAINS THE VALUE ON THE TOP OF THE
*	STACK. A VALUE OF ZERO FOR STKTOP INDICATES THAT THE STACK IS
*	EMPTY.
*
STKTOP SET STKTOP+1
 IFEQ STKTOP-1
S1 SET \0
L1 SET ISLONG
 EXIT
 ENDC
 IFEQ	STKTOP-2
S2 SET	  \0
L2 SET ISLONG
 EXIT
 ENDC
 IFEQ  STKTOP-3
S3 SET \0
L3 SET ISLONG
 EXIT
 ENDC
 IFEQ STKTOP-4
S4 SET \0
L4 SET ISLONG
 EXIT
 ENDC
 IFEQ STKTOP-5
S5 SET \0
L5 SET ISLONG
 EXIT
 ENDC
 IFEQ STKTOP-6
S6 SET \0
L6 SET ISLONG
 EXIT
 ENDC
 IFEQ STKTOP-7
S7 SET \0
L7 SET ISLONG
 EXIT
 ENDC
 IFEQ STKTOP-8
S8 SET \0
L8 SET ISLONG
 EXIT
 ENDC
 IFEQ STKTOP-9
S9 SET \0
L9 SET ISLONG
 EXIT
 ENDC
 IFEQ STKTOP-10
S10 SET \0
L10 SET ISLONG
 EXIT
 ENDC
 IFGT STKTOP-10
 FAIL ** SYMBOL STACK OVERFLOW **
 ENDC
 ENDM
POP MACR
***********************************************************************
*
*	POP --
*		THE POP MACRO REMOVES THE TOPMOST ELEMENT FROM THE
*	SIMULATED STACK.
*
 IFLE STKTOP
 FAIL ** SYMBOL STACK UNDERFLOW **
 ENDC
 IFGT STKTOP
STKTOP SET STKTOP-1
 ENDC
 ENDM
BACK1 MACR
************************************************************************
*
*	BACK1	--
*		THIS MACRO SETS THE ASSEMBLER'S LOCATION COUNTER TO
*	THE VALUE ON THE TOP OF THE STACK. CODE GENERATED AFTER THIS
*	MACRO IS CALLED WILL BE LOCATED AT THE ADDRESS CONTAINED ON
*	THE TOP OF THE SYMBOL STACK.
*		THE CONTENTS OF THE STACK ARE NOT CHANGED BY THIS
*	MACRO.
*
 IFEQ STKTOP-1
 ORG S1
BCKLNG SET L1
 EXIT
 ENDC
 IFEQ STKTOP-2
 ORG S2
BCKLNG SET L2
 EXIT
 ENDC
 IFEQ STKTOP-3
 ORG S3
BCKLNG SET L3
 EXIT
 ENDC
 IFEQ STKTOP-4
 ORG S4
BCKLNG SET L4
 EXIT
 ENDC
 IFEQ STKTOP-5
 ORG S5
BCKLNG SET L5
 EXIT
 ENDC
 IFEQ STKTOP-6
 ORG S6
BCKLNG SET L6
 EXIT
 ENDC
 IFEQ STKTOP-7
 ORG S7
BCKLNG SET L7
 EXIT
 ENDC
 IFEQ STKTOP-8
 ORG S8
BCKLNG SET L8
 EXIT
 ENDC
 IFEQ STKTOP-9
 ORG S9
BCKLNG SET L9
 EXIT
 ENDC
 IFEQ STKTOP-10
 ORG S10
BCKLNG SET S10
 EXIT
 ENDC
 IFLE STKTOP
 FAIL ** REFERENCE WAS MADE TO EMPTY SYMBOL STACK **
 EXIT
 ENDC
 IFGT STKTOP-7
 FAIL ** STACK TOP POINTER EXCEEDS STACK **
 EXIT
 ENDC
 ENDM
RELOP MACR
**********************************************************************
*
*	RELOP --
*		THIS MACRO CREATES A RELATIVE BRANCH INSTRUCTION
*	FOR THE 'IF', 'WHILE', AND 'UNTIL' MACROS BASED ON THE
*	RELATIONAL OPERATOR PASSED TO IT AS ITS FIRST ARGUMENT.
*
 IFC \0,EQ
  IFEQ ISLONG
  BNE *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBNE EXBUG
  EXIT
  ENDC
 ENDC
 IFC \0,NE
  IFEQ ISLONG
  BEQ *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBEQ EXBUG
  EXIT
  ENDC
 ENDC
 IFC \0,LE
  IFEQ ISLONG
  BGT *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBGT EXBUG
  EXIT
  ENDC
 ENDC
 IFC \0,LT
  IFEQ ISLONG
  BGE *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBGE EXBUG
  EXIT
  ENDC
 ENDC
 IFC \0,GE
  IFEQ ISLONG
  BLT *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBLT EXBUG
  EXIT
  ENDC
 ENDC
 IFC \0,GT
  IFEQ ISLONG
  BLE *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBLE EXBUG
  EXIT
  ENDC
 ENDC
 IFNC \0,EQ
  IFNC \0,NE
   IFNC \0,LT
    IFNC \0,LE
     IFNC \0,GE
      IFNC \0,GT
      FAIL ** INVALID RELATIONAL OPERATOR -- \0 **
      EXIT
      ENDC
     ENDC
    ENDC
   ENDC
  ENDC
 ENDC
 ENDM
RELTST MACR
*****************************************************************
*
*      RELTST --
*	     THE 'RELTST' MACRO TESTS THE VALIDITY OF THE
*      RELATIONAL OPERATOR USED WITH THE 'IFTST' MACRO AND
*      GENERATES THE PROPER RELATIVE BRANCH INSTRUCTION.
*
 IFC \0,EQ
  IFEQ ISLONG
  BNE *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBNE EXBUG
  EXIT
  ENDC
 ENDC
 IFC \0,NE
  IFEQ ISLONG
  BEQ *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBEQ EXBUG
  EXIT
  ENDC
 ENDC
 IFC \0,GE
  IFEQ ISLONG
  BLT *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBLT EXBUG
  EXIT
  ENDC
 ENDC
 IFC \0,LT
  IFEQ ISLONG
  BGE *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBGE EXBUG
  EXIT
  ENDC
 ENDC
 IFNC \0,EQ
  IFNC \0,NE
   IFNC \0,GE
    IFNC \0,LT
    FAIL ** \0 IS AN INVALID RELATIONAL OPERATOR FOR 'IFTST' **
    EXIT
    ENDC
   ENDC
  ENDC
 ENDC
 ENDM
RELCC MACR
**********************************************************************
*
*      RELCC --
*	     THE 'RELCC' MACRO TESTS THE VALIDITY OF THE RELATIONAL
*      OPERATOR FOR THE 'IFCC' MACRO AND GENERATES THE PROPER RELATIVE
*      BRANCH INSTRUCTION.
*
 IFC \0,EQ
  IFEQ ISLONG
  BNE *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBNE EXBUG
  EXIT
  ENDC
 ENDC
 IFC \0,NE
  IFEQ ISLONG
  BEQ *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBEQ EXBUG
  EXIT
  ENDC
 ENDC
 IFC \0,LE
  IFEQ ISLONG
  BGT *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBGT EXBUG
  EXIT
  ENDC
 ENDC
 IFC \0,LT
  IFEQ ISLONG
  BGE *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBGE EXBUG
  EXIT
  ENDC
 ENDC
 IFC \0,GE
  IFEQ ISLONG
  BLT *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBLT EXBUG
  EXIT
  ENDC
 ENDC
 IFC \0,GT
  IFEQ ISLONG
  BLE *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBLE EXBUG
  EXIT
  ENDC
 ENDC
 IFC \0,CC
  IFEQ ISLONG
  BCS *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBCS EXBUG
  EXIT
  ENDC
 ENDC
 IFC \0,CS
  IFEQ ISLONG
  BCC *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBCC EXBUG
  EXIT
  ENDC
 ENDC
 IFC \0,VC
  IFEQ ISLONG
  BVS *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBVS EXBUG
  EXIT
  ENDC
 ENDC
 IFC \0,VS
  IFEQ ISLONG
  BVC *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBVC EXBUG
  EXIT
  ENDC
 ENDC
 IFNC \0,EQ
  IFNC \0,NE
   IFNC \0,LT
    IFNC \0,LE
     IFNC \0,GE
      IFNC \0,GT
RELERR SET 1   ERROR FLAG FOR NEXT SET OF TESTS
      ENDC
     ENDC
    ENDC
   ENDC
  ENDC
 ENDC
 IFNE RELERR
RELERR SET 0
  IFNC \0,CC
   IFNC \0,VC
    IFNC \0,CS
     IFNC \0,VS
     FAIL ** INVALID RELATIONAL OPERATOR -- \0 **
     ENDC
    ENDC
   ENDC
  ENDC
 ENDC
 ENDM
REGTST MACR
**********************************************************************
*
*	REGTST --
*		THIS MACRO TESTS THE VALIDITY OF THE REGISTER
*	NAME PASSED AS ITS FIRST ARGUMENT. IF THE NAME WAS NOT
*	A VALID REGISTER, 'REGTST' WILL FAIL WITH AN ERROR MESSAGE.
*
 IFNC \0,A
 IFNC \0,B
 IFNC \0,D
 IFNC \0,X
 IFNC \0,Y
 IFNC \0,U
 IFNC \0,S
 FAIL ** \0 IS NOT A 6809 REGISTER **
 EXIT
 ENDC
 ENDC
 ENDC
 ENDC
 ENDC
 ENDC
 ENDC
 ENDM
IF MACR
**********************************************************************
*
*	IF --
*		THE 'IF' MACRO WILL CAUSE THE STATEMENTS FOLLOWING
*	IT TO BE EXECUTED UP TO THE FIRST 'ELSE' OR 'ENDIF' IF THE
*	CONDITIONAL EXPRESSION IS TRUE. ITS SYNTAX IS:
*
*	IF    <REGISTER NAME>,<RELATIONAL OPERATOR>,<ADDRESS EXPRESSION>
*
*	THE VALID RELATIONAL OPERATORS ARE: 'EQ','NE','LE','LT',
*	'GE', AND 'GT'.
*
 IFNE NARG-3
  IFNC \3,L
  FAIL ** 'IF' MACRO REQUIRES 3 ARGUMENTS **
  ENDC
 ENDC
 IFC \3,L
ISLONG SET 1
 ENDC
 REGTST \0
 CMP\0 \2
 RELOP \1
 PUSH *-1-ISLONG
ISLONG SET 0
 ENDM
ELSE MACR
**********************************************************************
*
*	ELSE --
*		THE 'ELSE' MACRO BEGINS THE STATEMENTS THAT WILL
*	BE EXECUTED IF THE CONDITIONAL EXPRESSION OF THE PRECEDING
*	'IF' MACRO WAS NOT TRUE.
*
 IFC \0,L
ISLONG SET 1
 ENDC
 IFEQ ISLONG
 BRA *
 ENDC
 IFEQ ISLONG-1
 LBRA EXBUG
 ENDC
MCRTMP SET *
 BACK1
 IFEQ BCKLNG
 IFGT (MCRTMP-*-1)-128
 FAIL ** LONG 'IF' IS REQUIRED **
 ENDC
 FCB MCRTMP-*-1
 ENDC
 IFEQ BCKLNG-1
 FDB MCRTMP-*-2
 ENDC
 ORG MCRTMP
 POP
 PUSH *-1-ISLONG
ISLONG SET 0
 ENDM
ENDIF MACR
**********************************************************************
*
*	ENDIF --
*		THE 'ENDIF' MACRO IS THE TERMINATING STATEMENT FOR THE
*	STATEMENTS CONTROLLED BY THE PRECEDING 'IF' OR 'ELSE' MACRO.
*
MCRTMP SET *
 BACK1
 IFEQ BCKLNG
 IFGT (MCRTMP-*-1)-128
 FAIL ** LONG 'ELSE' REQUIRED **
 ENDC
 FCB MCRTMP-*-1
 ENDC
 IFEQ BCKLNG-1
 FDB MCRTMP-*-2
 ENDC
 ORG MCRTMP
 POP
 ENDM
IFTST MACR
**********************************************************************
*
*	IFTST --
*		THE 'IFTST' MACRO OPERATES LIKE AN 'IF' MACRO EXCEPT
*	THAT IT GENERATES A 'TST' INSTRUCTION INSTEAD OF A 'CMP'.
*	THE SYNTAX IS:
*
*	IFTST	<REGISTER OR ADDRESS EXPRESSION>,<RELATIONAL OP>,0
*
*	THE VALID RELATIONAL OPERATORS FOR USE WITH 'IFTST' ARE: 'EQ',
*	'NE', 'LT', AND 'GE'.
*
 IFC \3,L
ISLONG SET 1
 ENDC
 IFC \2,L
ISLONG SET 1
 ENDC
 IFC \0,A
 TSTA
 ENDC
 IFC \0,B
 TSTB
 ENDC
 IFNC \0,A
  IFNC \0,B
  TST \0
  ENDC
 ENDC
 RELTST \1
 PUSH *-1-ISLONG
ISLONG SET 0
 ENDM
IFCC MACR
**********************************************************************
*
*	IFCC --
*		THE 'IFCC' MACRO FUNCTIONS LIKE AN 'IF' MACRO, EXCEPT
*	IT ONLY GENERATES A 'BRANCH ON CONDITION' INSTRUCTION DIRECTLY.
*	THIS IS USEFUL BECAUSE IT ALLOWS THE ASSEMBLER TO GENERATE THE
*	LABEL FOR THE BRANCH INSTEAD OF FORCING THAT BURDEN ON THE
*	OVER-WORKED PROGRAMMER. THE SYNTAX IS:
*
*	IFCC   <RELATIONAL OPERATOR>
*
*	THE VALID REALTIONAL OPERATORS ARE: 'EQ', 'NE', 'GE', 'GT',
*	'LE', AND 'LT'.
*
 IFNE NARG-1
  IFNC \1,L
  FAIL ** ONLY ONE ARGUMENT (A RELATIONAL OPERATOR) ALLOWED **
  ENDC
 ENDC
 IFC \1,L
ISLONG SET 1
 ENDC
 RELCC \0
 PUSH *-1-ISLONG
ISLONG SET 0
 ENDM
WHILE MACR
**********************************************************************
*
*	WHILE --
*		THE 'WHILE' MACRO EXECUTES THE STATEMENTS FOLLOWING
*	IT UP TO THE 'ENDWH' AS LONG AS ITS CONDITIONAL EXPRESSION IS
*	TRUE. THE SNTAX IS:
*
*	WHILE <REGISTER NAME>,<RELATIONAL OPERATOR>,<ADDRESS EXPRESSION>
*
 IFNE NARG-3
  IFNC \3,L
  FAIL ** 'WHILE' REQUIRES 3 ARGUMENTS **
  ENDC
 ENDC
 IFC \3,L
ISLONG SET 1
 ENDC
 PUSH *
 REGTST \0
 CMP\0 \2
 RELOP \1
 PUSH *-1-ISLONG
ISLONG SET 0
 ENDM
ENDWH MACR
**********************************************************************
*
*	ENDWH --
*		THIS MACRO TERMINATES THE STATEMENTS WITHIN A 'WHILE'
*	LOOP.
*
 IFC \0,L
  FAIL ** THE 'LONG' SHOULD BE PLACED ON THE 'WHILE' **
 ENDC
MCRTMP SET *
 BACK1
 IFEQ BCKLNG
  IFGT -((MCRTMP+2)-*-1)-128
  FAIL ** LONG 'WHILE' IS REQUIRED **
  ENDC
 FCB (MCRTMP+2)-*-1
 ENDC
 IFEQ BCKLNG-1
 FDB (MCRTMP+3)-*-2
 ENDC
 POP
 BACK1
\.A EQU *
 ORG MCRTMP
 IFEQ BCKLNG
 BRA \.A
 ENDC
 IFEQ BCKLNG-1
 LBRA \.A
 ENDC
 POP
 ENDM
REPEAT MACR
**********************************************************************
*
*	REPEAT --
*		THE STATEMENTS BETWEEN A 'REPEAT' AND AN 'UNTIL' MACRO
*	ARE REPEATED UNTIL THE CONDITIONAL EXPRESSION BECOMES TRUE.
*
 IFC \0,L
  FAIL ** PLACE 'LONG' ON THE 'UNTIL' **
 ENDC
 PUSH *
 ENDM
UNTIL MACR
**********************************************************************
*
*	UNTIL --
*		THE 'UNTIL' MACRO TERMINATES A 'REPEAT' LOOP. IT HAS
*	THE SYNTAX:
*
*	UNTIL  <REGISTER NAME>,<RELATIONAL OPERATOR>,<ADDRESS EXPRESSION>
*
 IFNE NARG-3
  IFNC \3,L
  FAIL ** 'UNTIL' REQUIRES 3 ARGUMENTS **
  ENDC
 ENDC
 IFC \3,L
ISLONG SET 1
 ENDC
MCRTMP SET *
 BACK1
\.A EQU *
 ORG MCRTMP
 POP
 REGTST \0
 CMP\0 \2
 RELOP \1
 ORG *-1-ISLONG
 IFEQ ISLONG
  IFGT -(\.A-*-1)-128
  FAIL ** LONG 'UNTIL' IS REQUIRED **
  ENDC
  FCB \.A-*-1
 ENDC
 IFEQ ISLONG-1
 FDB \.A-*-2
 ENDC
ISLONG SET 0
 ENDM
*
*
*
*
 PAG
*
*
*
************************************************
*
*   S H I F T	M A C R O S
*
************************************************
*
*
*
*
RSHIFT MACR
*
*
*  THIS MACRO DOES A RIGHT SHIFT ON A MULTI-
* PRECISION OPERAND THAT IS UP TO 10 BYTES
* LONG, WHOSE MOST SIG. BYTE IS POINTED TO
* BY EITHER 0FF,X , OFF,Y , OR OFF,U; WHERE
* "OFF" IS A CONSTANT OFFSET SPECIFIED UPON
* INVOCATION OF THE MACRO. THE CARRY IS SHIFTED
* IN FROM THE RIGHT.
*
*
* TO INVOKE RSHIFT:
*
*     RSHIFT  <"OFF">,< X, Y OR U >,< BYTE LENGTH >
*
* CHECK FOR PROPER NO. OF ARGUMENTS
*
 IFNE  NARG-3
   FAIL  ** TO FEW OR TO MANY ARGUMENTS **
   EXIT
 ENDC
*
* CHECK FOR PROPER POINTER REG.( X , Y OR U )
*
 IFNC  \1,X
   IFNC  \1,Y
     IFNC  \1,U
       FAIL  ** \1 IS AN INVALID POINTER REG. **
       EXIT
     ENDC
   ENDC
 ENDC
*
* CHECK NO. OF BYTES ARGUMENT; MUST BE > 0
* AND <= 10.
*
 IFLE  \2
   FAIL  ** SHIFT BYTE COUNT MUST BE > 0 **
   EXIT
 ENDC
*
 IFGT  \2-10
   FAIL  ** SHIFT BYTE COUNT MUST BE <= 10 **
   EXIT
 ENDC
*
* START CODE GENERATION
*
 ROR  \0,\1
 IFGT  (\2)-1
   ROR	(\0)+1,\1
 ENDC
   IFGT  (\2)-2
     ROR  (\0)+2,\1
   ENDC
     IFGT  (\2)-3
       ROR  (\0)+3,\1
     ENDC
       IFGT  (\2)-4
	 ROR  (\0)+4,\1
       ENDC
	 IFGT  (\2)-5
	   ROR	(\0)+5,\1
	 ENDC
	   IFGT  (\2)-6
	     ROR  (\0)+6,\1
	   ENDC
	     IFGT  (\2)-7
	       ROR  (\0)+7,\1
	     ENDC
	       IFGT  (\2)-8
		 ROR  (\0)+8,\1
	       ENDC
		 IFGT  (\2)-9
		   ROR	(\0)+9,\1
		 ENDC
*
*
 ENDM
*
*
*
 PAG
*
*
*
*
*
LSHIFT MACR
*
*
*  THIS MACRO DOES A LEFT SHIFT ON A MULTI-
* PRECISION OPERAND THAT IS UP TO 10 BYTES
* LONG, WHOSE MOST SIG. BYTE IS POINTED TO
* BY EITHER 0FF,X , OFF,Y , OR OFF,U; WHERE
* "OFF" IS A CONSTANT OFFSET SPECIFIED UPON
* INVOCATION OF THE MACRO. THE CARRY IS SHIFTED
* IN FROM THE LEFT.
*
* TO INVOKE LSHIFT:
*
*     LSHIFT  <"0FF">,< X,Y OR U >,< BYTE LENGTH >
*
* CHECK FOR PROPER NO. OF ARGUMENTS
*
 IFNE  NARG-3
   FAIL  ** TO FEW OR TO MANY ARGUMENTS **
   EXIT
 ENDC
*
* CHECK FOR PROPER POINTER REG.( X OR Y )
*
 IFNC  \1,X
   IFNC  \1,Y
     IFNC  \1,U
       FAIL  ** \1 IS AN INVALID POINTER REG. **
       EXIT
     ENDC
   ENDC
 ENDC
*
* CHECK NO. OF BYTES ARGUMENT; MUST BE > 0
* AND <= 10.
*
 IFLE  \2
   FAIL  ** SHIFT BYTE COUNT MUST BE > 0 **
   EXIT
 ENDC
*
 IFGT  \2-10
   FAIL  ** SHIFT BYTE COUNT MUST BE <= 10 **
   EXIT
 ENDC
*
* START CODE GENERATION
*
 ROL  (\0)+(\2)-1,\1
 IFGT  (\2)-1
   ROL	(\0)+(\2)-2,\1
 ENDC
   IFGT  (\2)-2
     ROL  (\0)+(\2)-3,\1
   ENDC
     IFGT  (\2)-3
       ROL  (\0)+(\2)-4,\1
     ENDC
       IFGT  (\2)-4
	 ROL  (\0)+(\2)-5,\1
       ENDC
	 IFGT  (\2)-5
	   ROL	(\0)+(\2)-6,\1
	 ENDC
	   IFGT  (\2)-6
	     ROL  (\0)+(\2)-7,\1
	   ENDC
	     IFGT  (\2)-7
	       ROL  (\0)+(\2)-8,\1
	     ENDC
	       IFGT  (\2)-8
		 ROL  (\0)+(\2)-9,\1
	       ENDC
		 IFGT  (\2)-9
		   ROL	(\0)+(\2)-10,\1
		 ENDC
*
*
 ENDM
*
*
 PAG
*
*
*

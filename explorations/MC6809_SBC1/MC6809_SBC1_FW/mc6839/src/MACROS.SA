 PAGE
*
**************************************************************
*
*
*     G L O B A L   M A C R O S
*
*
**************************************************************
*
****************
*
* SRD
*   MACRO TO LOGICAL DOUBLE SHIFT D-REG N BITS RIGHT. (1 <= N <= 8)
*
*   CALL:  SRD N
*
SRD MACR
 IFGT (\0)-8 LOOK FOR ILLEGAL CASES
 FAIL *** SRD N; N <= 8 ***
 ENDC
 IFLT (\0)-1
 FAIL *** SRD N; N >= 0 ***
 ENDC
* N IS OKAY; DO THE SHIFTS
 IFEQ (\0)-8
 LSRA
 RORB
 ENDC
 IFGE (\0)-7
 LSRA
 RORB
 ENDC
 IFGE (\0)-6
 LSRA
 RORB
 ENDC
 IFGE (\0)-5
 LSRA
 RORB
 ENDC
 IFGE (\0)-4
 LSRA
 RORB
 ENDC
 IFGE (\0)-3
 LSRA
 RORB
 ENDC
 IFGE (\0)-2
 LSRA
 RORB
 ENDC
 IFGE (\0)-1
 LSRA
 RORB
 ENDC
 ENDM
 PAGE
*
*****************
*
* SLD N
*   MACRO TO LOGICALLY SHIFT D-REG N BITS OO
*   THE LEFT. (1 <= N <= 8)
*
*   CALL: SLD N
*
*****************
*
SLD MACR
* CATCH THE ILLEGAL CASES
 IFGT (\0)-8
 FAIL *** SSLD N; N <= 8 ***
 ENDC
 IFLT (\0)-1
 FAIL *** SLD N; N >= 0 ***
 ENDC
 IFEQ (\0)-8
 LSLB
 ROLA
 ENDC
 IFGE (\0)-7
 LSLB
 ROLA
 ENDC
 IFGE (\0)-6
 LSLB
 ROLA
 ENDC
 IFGE (\0)-5
 LSLB
 ROLA
 ENDC
 IFGE (\0)-4
 LSLB
 ROLA
 ENDC
 IFGE (\0)-3
 LSLB
 ROLA
 ENDC
 IFGE (\0)-2
 LSLB
 ROLA
 ENDC
 IFGE (\0)-1
 LSLB
 ROLA
 ENDC
 ENDM
 PAGE
*
*****************
*
* MOVE MACROS
*   THIS SET OF MACROS MOVES A SOURCE OPERAND TO
*   A DESTINATION OPERAND USING THE SPECIFIED
*   REGISTER AS INTERMEDIATE.
*
*   MOV<A|B|D|X|Y|U|S> <SOURCE>,<DEST>
*
*****************
*
MOVD MACR
     LDD \0
     STD \1
     ENDM
*
MOVA MACR
     LDA \0
     STA \1
     ENDM
*
MOVB MACR
     LDB \0
     STB \1
     ENDM
*
MOVX MACR
     LDX \0
     STX \1
     ENDM
*
MOVY MACR
     LDY \0
     STY \1
     ENDM
*
MOVU MACR
     LDU \0
     STU \1
     ENDM
*
MOVS MACR
     LDS \0
     STS \1
     ENDM
 PAGE
*
**********************************************
*
* BIT MANIPULATION MACROS
*   BSET  SET A BIT IN MEMORY
*   BCLR  CLEAR A BIT IN MEMORY
*
*   SET OR CLEAR A BIT IN MEMORY. THE FORMAT
*   OF THE CALL IS:
*    BSET<A|B> <BIT#>,<MEMORY LOCATION>
*    BCLR<A|B> <BIT#>,<MEMORY LOCATION>
*
*    THE A OR B REGISTER MUST BE SPECIFIED AND IT
*    PROVIDES THE INTERMEDIATE SCRATCH REGISTER.
*
*    THE BIT NUMBER CAN BE ONE OR MORE BITS
*
**********************
*
BSETA MACR
      LDA \1
      ORA #(\0)
      STA \1
      ENDM
*
BSETB MACR
      LDB \1
      ORB #(\0)
      STB \1
      ENDM
*
BCLRA MACR
      LDA \1
      ANDA #(-(\0)-1)!.$FF
      STA \1
      ENDM
*
BCLRB MACR
      LDB \1
      ANDB  ((-(\0)-1)!.$FF
      STB \1
      ENDM
 PAGE
*
***********************************************
*
*  INCREMENT AND DECREMENT 16 BIT REGISTESS
*
***********************************************
*
INCX MACR
 LEAX 1,X
 ENDM
*
DECX MACR
 LEAX -1,X
 ENDM
*
INCY MACR
 LEAY 1,Y
 ENDM
*
DECY MACR
 LEAY -1,Y
 ENDM
*
INCU MACR
 LEAU 1,U
 ENDM
*
DECU MACR
 LEAU -1,U
 ENDM
*
INCS MACR
 LEAS 1,S
 ENDM
*
DECS MACR
 LEAS -1,S
 ENDM
*
INCD MACR
 INCB
 BNE *+3
 INCA
 ENDM
*
DECD MACR
 TSTB
 BNE \.1
 DECA
\.1 DECB
 ENDM
*

 PAGE
*
******************
*
*  IOP N
*
*    MACRO TO SET INVALID OPERATION STATUS BITS IN
*    THE TEMPORARY STATUS BYTES ON THE STACK FRAME
*    SETS IOP BIT AND INVALID OPERATION CODE.
*
*  CALL: IOP N
*    WHERE N IS A VALID INVALID OPERATION NUMBER
*   USES A REGISTER
*
* USES A-REGISTER
*
*****************
*
IOP MACR
* CHECK FOR ILLEGAL CASES
 IFLT (\0)-1
 FAIL *** IOP N; N > 0 ***
 ENDC
 IFGT (\0)-BIGIOP
 FAIL *** IOP N; N TOO BIG ***
 ENDC
* NOT ILLEGAL
 LDA #(\0)
 LBSR  IOPSUB		SET IOP CODE,IOP BIT & RETURN A NAN
 ENDM
 PAGE
***********************************************************************
*
*	STRUCTURED MACROS FOR ASSEMBLY LANGUAGE PROGRAMMING THE 6809
*	BY JOEL BONEY
*	   GREG WALKER
*
EXBUG EQU $F000
STKTOP SET 0
ISLONG SET 0
PUSH MACR
***********************************************************************
*
*	PUSH --
*		THIS MACRO SIMULATES A 7-LEVEL STACK USING SEVEN SYMBOLS
*	WHOSE VALUES ARE REDEFINED TO BE THE VALUES ON THE STACK. THE
*	SYMBOL "STKTOP" CONTAINS A NUMBER FROM 0 TO 7 WHICH INDICATES
*	THE SYMBOL (S1 TO S7) THAT CONTAINS THE VALUE ON THE TOP OF THE
*	STACK. A VALUE OF ZERO FOR STKTOP INDICATES THAT THE STACK IS
*	EMPTY.
*
STKTOP SET STKTOP+1
 IFEQ STKTOP-1
S1 SET \0
L1 SET ISLONG
 EXIT
 ENDC
 IFEQ	STKTOP-2
S2 SET	  \0
L2 SET ISLONG
 EXIT
 ENDC
 IFEQ  STKTOP-3
S3 SET \0
L3 SET ISLONG
 EXIT
 ENDC
 IFEQ STKTOP-4
S4 SET \0
L4 SET ISLONG
 EXIT
 ENDC
 IFEQ STKTOP-5
S5 SET \0
L5 SET ISLONG
 EXIT
 ENDC
 IFEQ STKTOP-6
S6 SET \0
L6 SET ISLONG
 EXIT
 ENDC
 IFEQ STKTOP-7
S7 SET \0
L7 SET ISLONG
 EXIT
 ENDC
 IFEQ STKTOP-8
S8 SET \0
L8 SET ISLONG
 EXIT
 ENDC
 IFEQ STKTOP-9
S9 SET \0
L9 SET ISLONG
 EXIT
 ENDC
 IFEQ STKTOP-10
S10 SET \0
L10 SET ISLONG
 EXIT
 ENDC
 IFGT STKTOP-10
 FAIL ** SYMBOL STACK OVERFLOW **
 ENDC
 ENDM
POP MACR
***********************************************************************
*
*	POP --
*		THE POP MACRO REMOVES THE TOPMOST ELEMENT FROM THE
*	SIMULATED STACK.
*
 IFLE STKTOP
 FAIL ** SYMBOL STACK UNDERFLOW **
 ENDC
 IFGT STKTOP
STKTOP SET STKTOP-1
 ENDC
 ENDM
BACK1 MACR
************************************************************************
*
*	BACK1	--
*		THIS MACRO SETS THE ASSEMBLER'S LOCATION COUNTER TO
*	THE VALUE ON THE TOP OF THE STACK. CODE GENERATED AFTER THIS
*	MACRO IS CALLED WILL BE LOCATED AT THE ADDRESS CONTAINED ON
*	THE TOP OF THE SYMBOL STACK.
*		THE CONTENTS OF THE STACK ARE NOT CHANGED BY THIS
*	MACRO.
*
 IFEQ STKTOP-1
 ORG S1
BCKLNG SET L1
 EXIT
 ENDC
 IFEQ STKTOP-2
 ORG S2
BCKLNG SET L2
 EXIT
 ENDC
 IFEQ STKTOP-3
 ORG S3
BCKLNG SET L3
 EXIT
 ENDC
 IFEQ STKTOP-4
 ORG S4
BCKLNG SET L4
 EXIT
 ENDC
 IFEQ STKTOP-5
 ORG S5
BCKLNG SET L5
 EXIT
 ENDC
 IFEQ STKTOP-6
 ORG S6
BCKLNG SET L6
 EXIT
 ENDC
 IFEQ STKTOP-7
 ORG S7
BCKLNG SET L7
 EXIT
 ENDC
 IFEQ STKTOP-8
 ORG S8
BCKLNG SET L8
 EXIT
 ENDC
 IFEQ STKTOP-9
 ORG S9
BCKLNG SET L9
 EXIT
 ENDC
 IFEQ STKTOP-10
 ORG S10
BCKLNG SET S10
 EXIT
 ENDC
 IFLE STKTOP
 FAIL ** REFERENCE WAS MADE TO EMPTY SYMBOL STACK **
 EXIT
 ENDC
 IFGT STKTOP-7
 FAIL ** STACK TOP POINTER EXCEEDS STACK **
 EXIT
 ENDC
 ENDM
RELOP MACR
**********************************************************************
*
*	RELOP --
*		THIS MACRO CREATES A RELATIVE BRANCH INSTRUCTION
*	FOR THE 'IF', 'WHILE', AND 'UNTIL' MACROS BASED ON THE
*	RELATIONAL OPERATOR PASSED TO IT AS ITS FIRST ARGUMENT.
*
 IFC \0,EQ
  IFEQ ISLONG
  BNE *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBNE EXBUG
  EXIT
  ENDC
 ENDC
 IFC \0,NE
  IFEQ ISLONG
  BEQ *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBEQ EXBUG
  EXIT
  ENDC
 ENDC
 IFC \0,LE
  IFEQ ISLONG
  BGT *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBGT EXBUG
  EXIT
  ENDC
 ENDC
 IFC \0,LT
  IFEQ ISLONG
  BGE *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBGE EXBUG
  EXIT
  ENDC
 ENDC
 IFC \0,GE
  IFEQ ISLONG
  BLT *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBLT EXBUG
  EXIT
  ENDC
 ENDC
 IFC \0,GT
  IFEQ ISLONG
  BLE *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBLE EXBUG
  EXIT
  ENDC
 ENDC
 IFNC \0,EQ
  IFNC \0,NE
   IFNC \0,LT
    IFNC \0,LE
     IFNC \0,GE
      IFNC \0,GT
      FAIL ** INVALID RELATIONAL OPERATOR -- \0 **
      EXIT
      ENDC
     ENDC
    ENDC
   ENDC
  ENDC
 ENDC
 ENDM
RELTST MACR
*****************************************************************
*
*      RELTST --
*	     THE 'RELTST' MACRO TESTS THE VALIDITY OF THE
*      RELATIONAL OPERATOR USED WITH THE 'IFTST' MACRO AND
*      GENERATES THE PROPER RELATIVE BRANCH INSTRUCTION.
*
 IFC \0,EQ
  IFEQ ISLONG
  BNE *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBNE EXBUG
  EXIT
  ENDC
 ENDC
 IFC \0,NE
  IFEQ ISLONG
  BEQ *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBEQ EXBUG
  EXIT
  ENDC
 ENDC
 IFC \0,GE
  IFEQ ISLONG
  BLT *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBLT EXBUG
  EXIT
  ENDC
 ENDC
 IFC \0,LT
  IFEQ ISLONG
  BGE *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBGE EXBUG
  EXIT
  ENDC
 ENDC
 IFNC \0,EQ
  IFNC \0,NE
   IFNC \0,GE
    IFNC \0,LT
    FAIL ** \0 IS AN INVALID RELATIONAL OPERATOR FOR 'IFTST' **
    EXIT
    ENDC
   ENDC
  ENDC
 ENDC
 ENDM
RELCC MACR
**********************************************************************
*
*      RELCC --
*	     THE 'RELCC' MACRO TESTS THE VALIDITY OF THE RELATIONAL
*      OPERATOR FOR THE 'IFCC' MACRO AND GENERATES THE PROPER RELATIVE
*      BRANCH INSTRUCTION.
*
 IFC \0,EQ
  IFEQ ISLONG
  BNE *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBNE EXBUG
  EXIT
  ENDC
 ENDC
 IFC \0,NE
  IFEQ ISLONG
  BEQ *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBEQ EXBUG
  EXIT
  ENDC
 ENDC
 IFC \0,LE
  IFEQ ISLONG
  BGT *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBGT EXBUG
  EXIT
  ENDC
 ENDC
 IFC \0,LT
  IFEQ ISLONG
  BGE *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBGE EXBUG
  EXIT
  ENDC
 ENDC
 IFC \0,GE
  IFEQ ISLONG
  BLT *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBLT EXBUG
  EXIT
  ENDC
 ENDC
 IFC \0,GT
  IFEQ ISLONG
  BLE *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBLE EXBUG
  EXIT
  ENDC
 ENDC
 IFC \0,CC
  IFEQ ISLONG
  BCS *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBCS EXBUG
  EXIT
  ENDC
 ENDC
 IFC \0,CS
  IFEQ ISLONG
  BCC *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBCC EXBUG
  EXIT
  ENDC
 ENDC
 IFC \0,VC
  IFEQ ISLONG
  BVS *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBVS EXBUG
  EXIT
  ENDC
 ENDC
 IFC \0,VS
  IFEQ ISLONG
  BVC *
  EXIT
  ENDC
  IFEQ ISLONG-1
  LBVC EXBUG
  EXIT
  ENDC
 ENDC
 IFNC \0,EQ
  IFNC \0,NE
   IFNC \0,LT
    IFNC \0,LE
     IFNC \0,GE
      IFNC \0,GT
RELERR SET 1   ERROR FLAG FOR NEXT SET OF TESTS
      ENDC
     ENDC
    ENDC
   ENDC
  ENDC
 ENDC
 IFNE RELERR
RELERR SET 0
  IFNC \0,CC
   IFNC \0,VC
    IFNC \0,CS
     IFNC \0,VS
     FAIL ** INVALID RELATIONAL OPERATOR -- \0 **
     ENDC
    ENDC
   ENDC
  ENDC
 ENDC
 ENDM
REGTST MACR
**********************************************************************
*
*	REGTST --
*		THIS MACRO TESTS THE VALIDITY OF THE REGISTER
*	NAME PASSED AS ITS FIRST ARGUMENT. IF THE NAME WAS NOT
*	A VALID REGISTER, 'REGTST' WILL FAIL WITH AN ERROR MESSAGE.
*
 IFNC \0,A
 IFNC \0,B
 IFNC \0,D
 IFNC \0,X
 IFNC \0,Y
 IFNC \0,U
 IFNC \0,S
 FAIL ** \0 IS NOT A 6809 REGISTER **
 EXIT
 ENDC
 ENDC
 ENDC
 ENDC
 ENDC
 ENDC
 ENDC
 ENDM
IF MACR
**********************************************************************
*
*	IF --
*		THE 'IF' MACRO WILL CAUSE THE STATEMENTS FOLLOWING
*	IT TO BE EXECUTED UP TO THE FIRST 'ELSE' OR 'ENDIF' IF THE
*	CONDITIONAL EXPRESSION IS TRUE. ITS SYNTAX IS:
*
*	IF    <REGISTER NAME>,<RELATIONAL OPERATOR>,<ADDRESS EXPRESSION>
*
*	THE VALID RELATIONAL OPERATORS ARE: 'EQ','NE','LE','LT',
*	'GE', AND 'GT'.
*
 IFNE NARG-3
  IFNC \3,L
  FAIL ** 'IF' MACRO REQUIRES 3 ARGUMENTS **
  ENDC
 ENDC
 IFC \3,L
ISLONG SET 1
 ENDC
 REGTST \0
 CMP\0 \2
 RELOP \1
 PUSH *-1-ISLONG
ISLONG SET 0
 ENDM
ELSE MACR
**********************************************************************
*
*	ELSE --
*		THE 'ELSE' MACRO BEGINS THE STATEMENTS THAT WILL
*	BE EXECUTED IF THE CONDITIONAL EXPRESSION OF THE PRECEDING
*	'IF' MACRO WAS NOT TRUE.
*
 IFC \0,L
ISLONG SET 1
 ENDC
 IFEQ ISLONG
 BRA *
 ENDC
 IFEQ ISLONG-1
 LBRA EXBUG
 ENDC
MCRTMP SET *
 BACK1
 IFEQ BCKLNG
 IFGT (MCRTMP-*-1)-128
 FAIL ** LONG 'IF' IS REQUIRED **
 ENDC
 FCB MCRTMP-*-1
 ENDC
 IFEQ BCKLNG-1
 FDB MCRTMP-*-2
 ENDC
 ORG MCRTMP
 POP
 PUSH *-1-ISLONG
ISLONG SET 0
 ENDM
ENDIF MACR
**********************************************************************
*
*	ENDIF --
*		THE 'ENDIF' MACRO IS THE TERMINATING STATEMENT FOR THE
*	STATEMENTS CONTROLLED BY THE PRECEDING 'IF' OR 'ELSE' MACRO.
*
MCRTMP SET *
 BACK1
 IFEQ BCKLNG
 IFGT (MCRTMP-*-1)-128
 FAIL ** LONG 'ELSE' REQUIRED **
 ENDC
 FCB MCRTMP-*-1
 ENDC
 IFEQ BCKLNG-1
 FDB MCRTMP-*-2
 ENDC
 ORG MCRTMP
 POP
 ENDM
IFTST MACR
**********************************************************************
*
*	IFTST --
*		THE 'IFTST' MACRO OPERATES LIKE AN 'IF' MACRO EXCEPT
*	THAT IT GENERATES A 'TST' INSTRUCTION INSTEAD OF A 'CMP'.
*	THE SYNTAX IS:
*
*	IFTST	<REGISTER OR ADDRESS EXPRESSION>,<RELATIONAL OP>,0
*
*	THE VALID RELATIONAL OPERATORS FOR USE WITH 'IFTST' ARE: 'EQ',
*	'NE', 'LT', AND 'GE'.
*
 IFC \3,L
ISLONG SET 1
 ENDC
 IFC \2,L
ISLONG SET 1
 ENDC
 IFC \0,A
 TSTA
 ENDC
 IFC \0,B
 TSTB
 ENDC
 IFNC \0,A
  IFNC \0,B
  TST \0
  ENDC
 ENDC
 RELTST \1
 PUSH *-1-ISLONG
ISLONG SET 0
 ENDM
IFCC MACR
**********************************************************************
*
*	IFCC --
*		THE 'IFCC' MACRO FUNCTIONS LIKE AN 'IF' MACRO, EXCEPT
*	IT ONLY GENERATES A 'BRANCH ON CONDITION' INSTRUCTION DIRECTLY.
*	THIS IS USEFUL BECAUSE IT ALLOWS THE ASSEMBLER TO GENERATE THE
*	LABEL FOR THE BRANCH INSTEAD OF FORCING THAT BURDEN ON THE
*	OVER-WORKED PROGRAMMER. THE SYNTAX IS:
*
*	IFCC   <RELATIONAL OPERATOR>
*
*	THE VALID REALTIONAL OPERATORS ARE: 'EQ', 'NE', 'GE', 'GT',
*	'LE', AND 'LT'.
*
 IFNE NARG-1
  IFNC \1,L
  FAIL ** ONLY ONE ARGUMENT (A RELATIONAL OPERATOR) ALLOWED **
  ENDC
 ENDC
 IFC \1,L
ISLONG SET 1
 ENDC
 RELCC \0
 PUSH *-1-ISLONG
ISLONG SET 0
 ENDM
WHILE MACR
**********************************************************************
*
*	WHILE --
*		THE 'WHILE' MACRO EXECUTES THE STATEMENTS FOLLOWING
*	IT UP TO THE 'ENDWH' AS LONG AS ITS CONDITIONAL EXPRESSION IS
*	TRUE. THE SNTAX IS:
*
*	WHILE <REGISTER NAME>,<RELATIONAL OPERATOR>,<ADDRESS EXPRESSION>
*
 IFNE NARG-3
  IFNC \3,L
  FAIL ** 'WHILE' REQUIRES 3 ARGUMENTS **
  ENDC
 ENDC
 IFC \3,L
ISLONG SET 1
 ENDC
 PUSH *
 REGTST \0
 CMP\0 \2
 RELOP \1
 PUSH *-1-ISLONG
ISLONG SET 0
 ENDM
ENDWH MACR
**********************************************************************
*
*	ENDWH --
*		THIS MACRO TERMINATES THE STATEMENTS WITHIN A 'WHILE'
*	LOOP.
*
 IFC \0,L
  FAIL ** THE 'LONG' SHOULD BE PLACED ON THE 'WHILE' **
 ENDC
MCRTMP SET *
 BACK1
 IFEQ BCKLNG
  IFGT -((MCRTMP+2)-*-1)-128
  FAIL ** LONG 'WHILE' IS REQUIRED **
  ENDC
 FCB (MCRTMP+2)-*-1
 ENDC
 IFEQ BCKLNG-1
 FDB (MCRTMP+3)-*-2
 ENDC
 POP
 BACK1
\.A EQU *
 ORG MCRTMP
 IFEQ BCKLNG
 BRA \.A
 ENDC
 IFEQ BCKLNG-1
 LBRA \.A
 ENDC
 POP
 ENDM
REPEAT MACR
**********************************************************************
*
*	REPEAT --
*		THE STATEMENTS BETWEEN A 'REPEAT' AND AN 'UNTIL' MACRO
*	ARE REPEATED UNTIL THE CONDITIONAL EXPRESSION BECOMES TRUE.
*
 IFC \0,L
  FAIL ** PLACE 'LONG' ON THE 'UNTIL' **
 ENDC
 PUSH *
 ENDM
UNTIL MACR
**********************************************************************
*
*	UNTIL --
*		THE 'UNTIL' MACRO TERMINATES A 'REPEAT' LOOP. IT HAS
*	THE SYNTAX:
*
*	UNTIL  <REGISTER NAME>,<RELATIONAL OPERATOR>,<ADDRESS EXPRESSION>
*
 IFNE NARG-3
  IFNC \3,L
  FAIL ** 'UNTIL' REQUIRES 3 ARGUMENTS **
  ENDC
 ENDC
 IFC \3,L
ISLONG SET 1
 ENDC
MCRTMP SET *
 BACK1
\.A EQU *
 ORG MCRTMP
 POP
 REGTST \0
 CMP\0 \2
 RELOP \1
 ORG *-1-ISLONG
 IFEQ ISLONG
  IFGT -(\.A-*-1)-128
  FAIL ** LONG 'UNTIL' IS REQUIRED **
  ENDC
  FCB \.A-*-1
 ENDC
 IFEQ ISLONG-1
 FDB \.A-*-2
 ENDC
ISLONG SET 0
 ENDM
*
*
*
*
 PAG
*
*
*
************************************************
*
*   S H I F T	M A C R O S
*
************************************************
*
*
*
*
RSHIFT MACR
*
*
*  THIS MACRO DOES A RIGHT SHIFT ON A MULTI-
* PRECISION OPERAND THAT IS UP TO 10 BYTES
* LONG, WHOSE MOST SIG. BYTE IS POINTED TO
* BY EITHER 0FF,X , OFF,Y , OR OFF,U; WHERE
* "OFF" IS A CONSTANT OFFSET SPECIFIED UPON
* INVOCATION OF THE MACRO. THE CARRY IS SHIFTED
* IN FROM THE RIGHT.
*
*
* TO INVOKE RSHIFT:
*
*     RSHIFT  <"OFF">,< X, Y OR U >,< BYTE LENGTH >
*
* CHECK FOR PROPER NO. OF ARGUMENTS
*
 IFNE  NARG-3
   FAIL  ** TO FEW OR TO MANY ARGUMENTS **
   EXIT
 ENDC
*
* CHECK FOR PROPER POINTER REG.( X , Y OR U )
*
 IFNC  \1,X
   IFNC  \1,Y
     IFNC  \1,U
       FAIL  ** \1 IS AN INVALID POINTER REG. **
       EXIT
     ENDC
   ENDC
 ENDC
*
* CHECK NO. OF BYTES ARGUMENT; MUST BE > 0
* AND <= 10.
*
 IFLE  \2
   FAIL  ** SHIFT BYTE COUNT MUST BE > 0 **
   EXIT
 ENDC
*
 IFGT  \2-10
   FAIL  ** SHIFT BYTE COUNT MUST BE <= 10 **
   EXIT
 ENDC
*
* START CODE GENERATION
*
 ROR  \0,\1
 IFGT  (\2)-1
   ROR	(\0)+1,\1
 ENDC
   IFGT  (\2)-2
     ROR  (\0)+2,\1
   ENDC
     IFGT  (\2)-3
       ROR  (\0)+3,\1
     ENDC
       IFGT  (\2)-4
	 ROR  (\0)+4,\1
       ENDC
	 IFGT  (\2)-5
	   ROR	(\0)+5,\1
	 ENDC
	   IFGT  (\2)-6
	     ROR  (\0)+6,\1
	   ENDC
	     IFGT  (\2)-7
	       ROR  (\0)+7,\1
	     ENDC
	       IFGT  (\2)-8
		 ROR  (\0)+8,\1
	       ENDC
		 IFGT  (\2)-9
		   ROR	(\0)+9,\1
		 ENDC
*
*
 ENDM
*
*
*
 PAG
*
*
*
*
*
LSHIFT MACR
*
*
*  THIS MACRO DOES A LEFT SHIFT ON A MULTI-
* PRECISION OPERAND THAT IS UP TO 10 BYTES
* LONG, WHOSE MOST SIG. BYTE IS POINTED TO
* BY EITHER 0FF,X , OFF,Y , OR OFF,U; WHERE
* "OFF" IS A CONSTANT OFFSET SPECIFIED UPON
* INVOCATION OF THE MACRO. THE CARRY IS SHIFTED
* IN FROM THE LEFT.
*
* TO INVOKE LSHIFT:
*
*     LSHIFT  <"0FF">,< X,Y OR U >,< BYTE LENGTH >
*
* CHECK FOR PROPER NO. OF ARGUMENTS
*
 IFNE  NARG-3
   FAIL  ** TO FEW OR TO MANY ARGUMENTS **
   EXIT
 ENDC
*
* CHECK FOR PROPER POINTER REG.( X OR Y )
*
 IFNC  \1,X
   IFNC  \1,Y
     IFNC  \1,U
       FAIL  ** \1 IS AN INVALID POINTER REG. **
       EXIT
     ENDC
   ENDC
 ENDC
*
* CHECK NO. OF BYTES ARGUMENT; MUST BE > 0
* AND <= 10.
*
 IFLE  \2
   FAIL  ** SHIFT BYTE COUNT MUST BE > 0 **
   EXIT
 ENDC
*
 IFGT  \2-10
   FAIL  ** SHIFT BYTE COUNT MUST BE <= 10 **
   EXIT
 ENDC
*
* START CODE GENERATION
*
 ROL  (\0)+(\2)-1,\1
 IFGT  (\2)-1
   ROL	(\0)+(\2)-2,\1
 ENDC
   IFGT  (\2)-2
     ROL  (\0)+(\2)-3,\1
   ENDC
     IFGT  (\2)-3
       ROL  (\0)+(\2)-4,\1
     ENDC
       IFGT  (\2)-4
	 ROL  (\0)+(\2)-5,\1
       ENDC
	 IFGT  (\2)-5
	   ROL	(\0)+(\2)-6,\1
	 ENDC
	   IFGT  (\2)-6
	     ROL  (\0)+(\2)-7,\1
	   ENDC
	     IFGT  (\2)-7
	       ROL  (\0)+(\2)-8,\1
	     ENDC
	       IFGT  (\2)-8
		 ROL  (\0)+(\2)-9,\1
	       ENDC
		 IFGT  (\2)-9
		   ROL	(\0)+(\2)-10,\1
		 ENDC
*
*
 ENDM
*
*
 PAG
*
*
*
*************************************************
*
*    XPLUSY --
*
*	 THIS MACRO EFFICIENTLY ADDS THE 9-BYTE
*    FRACTION POINTED TO BY XREG TO THAT POINTED
*    TO BY YREG, LEAVING THE RESULT IN FRACTION
*    POINTED TO BY XREG.  CARRY OUT OF HIGH-ORDER
*    BIT IS IN CARRY FLAG.
*
XPLUSY	MACR
  LDD  7,X
  ADDD	7,Y
  STD  7,X
  LDD  5,X
  ADCD	(5,Y)
  STD  5,X
  LDD  3,X
  ADCD	(3,Y)
  STD  3,X
  LDD  1,X
  ADCD	(1,Y)
  STD  1,X
  LDB  0,X
  ADCB 0,Y
  STB  0,X
  ENDM
*
*************************************************
*
*    XSBTRY --
*
*	 MACRO TO SUBTRACT 9-BYTE FRACTION POINTED
*    TO BY Y-REG FROM THAT AT X-REG, RESULT STORED
*    X-REG.  IT IS EFFICIENT.
*
XSBTRY MACR
  LDD  7,X
  SUBD	7,Y
  STD  7,X
  LDD  5,X
  SBCD	(5,Y)
  STD  5,X
  LDD  3,X
  SBCD	(3,Y)
  STD  3,X
  LDD  1,X
  SBCD	(1,Y)
  STD  1,X
  LDB  0,X
  SBCB 0,Y
  STB  0,X
  ENDM
*
************************************************************
*
*  ADCD
*
*      ADCD SIMULATES WHAT WOULD BE THE ACTION OF A
*  ADDD W/ CARRY INSTRUCTION IF IT EXISTED, ALAS IT
*  DOESN'T SO IT IS DONE USING THE ADCA & ADCB INSTRUCTIONS
*
*  TO INVOKE ADCD: ADCD  <ADD. MODE>
*  NOTE: MUST ONLY USE CONSTANT OFFSETS
*
ADCD  MACR
*
  ADCB	1+\0
  ADCA	\0
*
 ENDM
*
************************************************************
*
*  SBCD
*
*      SBCD SIMULATES WHAT WOULD BE THE ACTION OF A
*  SUBD W/ CARRY INSTRUCTION IF IT EXISTED, ALAS IT
*  DOESN'T SO IT IS DONE USING THE SBCA & SBCB INSTRUCTIONS
*
*  TO INVOKE SBCD:  SBCD  <ADD. MODE>
*  NOTE: MUST ONLY USE CONSTANT OFFSETS
*
SBCD  MACR
*
  SBCB	1+\0
  SBCA	\0
*
 ENDM
*
*

0001                         ;
0002                         ; 6809 Trace Utility
0003                         ;
0004                         ; Copyright (C) 2019 by Jeff Tranter <tranter@pobox.com>
0005                         ;
0006                         ; Licensed under the Apache License, Version 2.0 (the "License");
0007                         ; you may not use this file except in compliance with the License.
0008                         ; You may obtain a copy of the License at
0009                         ;
0010                         ;   http://www.apache.org/licenses/LICENSE-2.0
0011                         ;
0012                         ; Unless required by applicable law or agreed to in writing, software
0013                         ; distributed under the License is distributed on an "AS IS" BASIS,
0014                         ; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0015                         ; See the License for the specific language governing permissions and
0016                         ; limitations under the License.
0017                         ;
0018                         ; Revision History
0019                         ; Version Date         Comments
0020                         ; 0.0     20-Mar-2019  First version started, based on 6502 code.
0021                         ; 0.1     25-Mar-2019  Basically working, with some limitations.
0022                         ; 0.2     27-Mar-2019  Mostly working, except for PCR and some corner cases.
0023                         ;
0024                         
0025                         ; Character defines
0026                         
0027 0004                    EOT     EQU     $04             ; String terminator
0028                         
0029                         ; Tables and routines in ASSIST09 ROM
0030                         
0031 c908                    OPCODES equ     $C908
0032 cb08                    PAGE2   equ     $CB08
0033 cb7b                    PAGE3   equ     $CB7B
0034 c8db                    LENGTHS equ     $C8DB
0035 ca08                    MODES   equ     $CA08
0036 c8e8                    POSTBYTES equ   $C8E8
0037                         
0038 c07e                    GetChar equ     $C07E
0039 c062                    Print2Spaces equ $C062
0040 c08f                    PrintAddress equ $C08F
0041 c081                    PrintByte equ   $C081
0042 c02e                    PrintCR equ     $C02E
0043 c07b                    PrintChar equ   $C07B
0044 c03b                    PrintDollar equ $C03B
0045 c05f                    PrintSpace equ  $C05F
0046 c09d                    PrintString equ $C09D
0047 5ff0                    ADRS    equ     $5FF0
0048 c0a4                    DISASM  equ     $C0A4
0049                         
0050                         ; Instruction types - taken from disassembler
0051                         
0052 0000                    OP_INV   EQU    $00
0053 0020                    OP_BSR   EQU    $20
0054 0030                    OP_CWAI  EQU    $30
0055 003b                    OP_JMP   EQU    $3B
0056 003c                    OP_JSR   EQU    $3C
0057 004b                    OP_LBSR  EQU    $4B
0058 006e                    OP_RTI   EQU    $6E
0059 006f                    OP_RTS   EQU    $6F
0060 007d                    OP_SWI   EQU    $7D
0061 007e                    OP_SWI2  EQU    $7E
0062 007f                    OP_SWI3  EQU    $7F
0063 0080                    OP_SYNC  EQU    $80
0064                         
0065                         ; Addressing modes - taken from disassembler
0066                         
0067 0000                    AM_INVALID    equ 0
0068 0006                    AM_RELATIVE8  equ 6
0069 0007                    AM_RELATIVE16 equ 7
0070                         
0071 0008                    AM_INDEXED equ  8
0072                         
0073 1000                            ORG     $1000
0074                         
0075                         ; Variables
0076                         
0077 1000                    SAVE_CC RMB     1               ; Saved register values
0078 1001                    SAVE_A  RMB     1
0079 1002                    SAVE_B  RMB     1
0080 1001                    SAVE_D  equ     SAVE_A          ; Synonym for SAVE_A and SAVE_B
0081 1003                    SAVE_DP RMB     1
0082 1004                    SAVE_X  RMB     2
0083 1006                    SAVE_Y  RMB     2
0084 1008                    SAVE_U  RMB     2
0085 100a                    SAVE_S  RMB     2
0086 100c                    SAVE_PC RMB     2
0087 100e                    ADDRESS RMB     2               ; Instruction address
0088 1010                    NEXTPC  RMB     2               ; Value of PC after next instruction
0089 1012                    OPCODE  RMB     1               ; Instruction op code
0090 1013                    OPTYPE  RMB     1               ; Instruction type (e.g. JMP)
0091 1014                    PAGE23  RMB     1               ; Flag indicating page2/3 instruction when non-zero
0092 1015                    POSTBYT RMB     1               ; Post byte (for indexed addressing)
0093 1016                    LENGTH  RMB     1               ; Length of instruction
0094 1017                    AM      RMB     1               ; Addressing mode
0095 1018                    OURS    RMB     2               ; This program's user stack pointer
0096 101a                    OURU    RMB     2               ; This program's system stack pointer
0097 101c                    BUFFER  RMB     10              ; Buffer holding traced instruction (up to 10 bytes)
0098                         
0099 2000                            ORG     $2000
0100                                 
0101                         ;------------------------------------------------------------------------
0102                         ; Code for testing trace function. Just contains a variety of
0103                         ; different instruction types.
0104                         
0105                         testcode
0106 2000 10 ce 50 00                lds     #$5000
0107 2004 ce 60 00                   ldu     #$6000
0108                         
0109 2007 8e 20 30           bubble  ldx     #base           ; Get table
0110 200a c6 0a                      ldb     #length         ; Get length
0111 200c 5a                         decb
0112 200d 30 85                      leax    b,x             ; Point to end
0113 200f 7f 20 2f                   clr     exchg           ; Clear exchange flag
0114 2012 a6 84              next    lda     ,x              ; A = current entry
0115 2014 a1 82                      cmpa    ,-x             ; Compare with next
0116 2016 2c 0d                      bge     noswit          ; Go to noswitch if current >= next (signed)
0117 2018 34 04                      pshs    b               ; Save B
0118 201a e6 84                      ldb     ,x              ; Get next
0119 201c e7 01                      stb     1,x             ; Store in current
0120 201e a7 84                      sta     ,x              ; Store current in next
0121 2020 35 04                      puls    b               ; Restore B
0122 2022 7c 20 2f                   inc     exchg           ; Set exchange flag
0123 2025 5a                 noswit  decb                    ; Decrement B
0124 2026 26 ea                      bne     next            ; Continue until zero
0125 2028 7d 20 2f                   tst     exchg           ; Exchange = 0?
0126 202b 26 da                      bne     bubble          ; Restart of no = 0
0127 202d 20 fe              forev   bra     forev
0128                         
0129                         ; Storage
0130                         
0131 202f                    exchg   rmb     1               ; Exchange flag
0132                         
0133                         ; Data to be sorted (random)
0134                         
0135 000a                    length  equ      10             ; Number of data items
0136                         
0137 2030 cb bb b8 cd a5 7e  base    fcb     203,187,184,205,165,126,19,253,30,24
     13 fd 1e 18
0138                         
0139 3000                            ORG     $3000
0140                         
0141                         ;------------------------------------------------------------------------
0142                         ; Main program
0143                         ; Trace test code. Pressing Q or q will go to monitor, any other key
0144                         ; will trace another instruction.
0145                         ; TODO: Make it work as an external command for ASSIST09.
0146                         
0147 3000 8e 20 00           main    ldx     #testcode       ; Start address of code to trace
0148 3003 bf 10 0e                   stx     ADDRESS
0149 3006 bf 10 0c                   stx     SAVE_PC
0150 3009 8d 14              loop    bsr     step
0151 300b bd 38 1c                   jsr     EchoOff         : Turn off echo from key press
0152 300e 17 90 6d                   lbsr    GetChar         ; Wait for a key press
0153 3011 81 51                      cmpa    #'Q'            ; Check for Q
0154 3013 27 06                      beq     quit            ; If so, quit
0155 3015 81 71                      cmpa    #'q'            ; Check for q
0156 3017 27 02                      beq     quit            ; If so, quit
0157 3019 20 ee                      bra     loop            ; If not, continue
0158 301b 6e 9f ff fe        quit    jmp     [$fffe]         ; Go back to ASSIST09 via reset vector
0159                         
0160                         ;------------------------------------------------------------------------
0161                         ; Step: Step one instruction
0162                         ; Get address to step.
0163                         ; Call Trace
0164                         ; Display register values
0165                         ; Disassemble next instruction (Set ADDR, call DISASM)
0166                         ; Return
0167                         
0168 301f 17 07 f0           step    lbsr    Disassemble     ; Disassemble the instruction
0169 3022 8d 0a                      bsr     Trace           ; Trace/execute the instruction
0170 3024 17 06 c5                   lbsr    DisplayRegs     ; Display register values
0171 3027 be 10 0e                   ldx     ADDRESS         ; Get next address
0172 302a bf 10 0c                   stx     SAVE_PC         ; And store as last PC
0173 302d 39                         rts
0174                         
0175                         ;------------------------------------------------------------------------
0176                         ; Trace one instruction.
0177                         ; Input: Address of instruction in ADDRESS.
0178                         ; Returns: Updates saved register values.
0179                         
0180 302e 7f 10 14           Trace   clr     PAGE23          ; Clear page2/3 flag
0181 3031 ae 8d df d9                ldx     ADDRESS,PCR     ; Get address of instruction
0182 3035 e6 84                      ldb     ,x              ; Get instruction op code
0183 3037 c1 10                      cmpb    #$10            ; Is it a page 2 16-bit opcode prefix with 10?
0184 3039 27 07                      beq     handle10        ; If so, do special handling
0185 303b c1 11                      cmpb    #$11            ; Is it a page 3 16-bit opcode prefix with 11?
0186 303d 27 52                      beq     handle11        ; If so, do special handling
0187 303f 16 00 9d                   lbra    not1011         ; If not, handle as normal case
0188                         
0189                         handle10                        ; Handle page 2 instruction
0190 3042 86 01                      lda     #1              ; Set page2/3 flag
0191 3044 b7 10 14                   sta     PAGE23
0192 3047 e6 01                      ldb     1,x             ; Get real opcode
0193 3049 f7 10 12                   stb     OPCODE          ; Save it.
0194 304c 30 8d 9a b8                leax    PAGE2,PCR       ; Pointer to start of table
0195 3050 4f                         clra                    ; Set index into table to zero
0196                         search10
0197 3051 e1 86                      cmpb    a,x             ; Check for match of opcode in table
0198 3053 27 1f                      beq     found10         ; Branch if found
0199 3055 8b 03                      adda    #3              ; Advance to next entry in table (entries are 3 bytes long)
0200 3057 6d 86                      tst     a,x             ; Check entry
0201 3059 27 02                      beq     notfound10      ; If zero, then reached end of table
0202 305b 20 f4                      bra     search10        ; If not, keep looking
0203                         
0204                         notfound10                      ; Instruction not found, so is invalid.
0205 305d 86 10                      lda     #$10            ; Set opcode to 10
0206 305f b7 10 12                   sta     OPCODE
0207 3062 86 00                      lda     #OP_INV         ; Set as instruction type invalid
0208 3064 b7 10 13                   sta     OPTYPE
0209 3067 86 00                      lda     #AM_INVALID     ; Set as addressing mode invalid
0210 3069 b7 10 17                   sta     AM
0211 306c 86 01                      lda     #1              ; Set length to one
0212 306e b7 10 16                   sta     LENGTH
0213 3071 16 00 8d                   lbra    dism            ; Disassemble as normal
0214                         
0215                         found10                         ; Found entry in table
0216 3074 8b 01                      adda    #1              ; Advance to instruction type entry in table
0217 3076 e6 86                      ldb     a,x             ; Get instruction type
0218 3078 f7 10 13                   stb     OPTYPE          ; Save it
0219 307b 8b 01                      adda    #1              ; Advanced to address mode entry in table
0220 307d e6 86                      ldb     a,x             ; Get address mode
0221 307f f7 10 17                   stb     AM              ; Save it
0222 3082 4f                         clra                    ; Clear MSB of D, addressing mode is now in A:B (D)
0223 3083 1f 01                      tfr     d,x             ; Put addressing mode in X
0224 3085 e6 89 c8 db                ldb     LENGTHS,x       ; Get instruction length from table
0225 3089 f7 10 16                   stb     LENGTH          ; Store it
0226 308c 7c 10 16                   inc     LENGTH          ; Add one because it is a two byte op code
0227 308f 20 70                      bra     dism            ; Continue normal disassembly processing.
0228                         
0229                         handle11                        ; Same logic as above, but use table for page 3 opcodes.
0230 3091 86 01                      lda     #1              ; Set page2/3 flag
0231 3093 b7 10 14                   sta     PAGE23
0232 3096 e6 01                      ldb     1,x             ; Get real opcode
0233 3098 f7 10 12                   stb     OPCODE          ; Save it.
0234 309b 30 8d 9a dc                leax    PAGE3,PCR       ; Pointer to start of table
0235 309f 4f                         clra                    ; Set index into table to zero
0236                         search11
0237 30a0 e1 86                      cmpb    a,x             ; Check for match of opcode in table
0238 30a2 27 1e                      beq     found11         ; Branch if found
0239 30a4 8b 03                      adda    #3              ; Advance to next entry in table (entries are 3 bytes long)
0240 30a6 6d 86                      tst     a,x             ; Check entry
0241 30a8 27 02                      beq     notfound11      ; If zero, then reached end of table
0242 30aa 20 f4                      bra     search11        ; If not, keep looking
0243                         
0244                         notfound11                      ; Instruction not found, so is invalid.
0245 30ac 86 11                      lda     #$11            ; Set opcode to 10
0246 30ae b7 10 12                   sta     OPCODE
0247 30b1 86 00                      LDA     #OP_INV         ; Set as instruction type invalid
0248 30b3 b7 10 13                   sta     OPTYPE
0249 30b6 86 00                      lda     #AM_INVALID     ; Set as addressing mode invalid
0250 30b8 b7 10 17                   sta     AM
0251 30bb 86 01                      lda     #1              ; Set length to one
0252 30bd b7 10 16                   sta     LENGTH
0253 30c0 20 3f                      bra     dism            ; Disassemble as normal
0254                         
0255                         found11                         ; Found entry in table
0256 30c2 8b 01                      adda    #1              ; Advance to instruction type entry in table
0257 30c4 e6 86                      ldb     a,x             ; Get instruction type
0258 30c6 f7 10 13                   stb     OPTYPE          ; Save it
0259 30c9 8b 01                      adda    #1              ; Advanced to address mode entry in table
0260 30cb e6 86                      ldb     a,x             ; Get address mode
0261 30cd f7 10 17                   stb     AM              ; Save it
0262 30d0 4f                         clra                    ; Clear MSB of D, addressing mode is now in A:B (D)
0263 30d1 1f 01                      tfr     d,x             ; Put addressing mode in X
0264 30d3 e6 89 c8 db                ldb     LENGTHS,x       ; Get instruction length from table
0265 30d7 f7 10 16                   stb     LENGTH          ; Store it
0266 30da 7c 10 16                   inc     LENGTH          ; Add one because it is a two byte op code
0267 30dd 20 22                      bra     dism            ; Continue normal disassembly processing.
0268                         
0269                         not1011
0270 30df f7 10 12                   stb     OPCODE          ; Save the op code
0271 30e2 4f                         clra                    ; Clear MSB of D
0272 30e3 1f 01                      tfr     d,x             ; Put op code in X
0273 30e5 e6 89 c9 08                ldb     OPCODES,x       ; Get opcode type from table
0274 30e9 f7 10 13                   stb     OPTYPE          ; Store it
0275 30ec f6 10 12                   ldb     OPCODE          ; Get op code again
0276 30ef 1f 01                      tfr     d,x             ; Put opcode in X
0277 30f1 e6 89 ca 08                ldb     MODES,x         ; Get addressing mode type from table
0278 30f5 f7 10 17                   stb     AM              ; Store it
0279 30f8 1f 01                      tfr     d,x             ; Put addressing mode in X
0280 30fa e6 89 c8 db                ldb     LENGTHS,x       ; Get instruction length from table
0281 30fe f7 10 16                   stb     LENGTH          ; Store it
0282                         
0283                         ; If addressing mode is indexed, get and save the indexed addressing
0284                         ; post byte.
0285                         
0286 3101 b6 10 17           dism    lda     AM              ; Get addressing mode
0287 3104 81 08                      cmpa    #AM_INDEXED     ; Is it indexed mode?
0288 3106 26 22                      bne     NotIndexed      ; Branch if not
0289 3108 ae 8d df 02                ldx     ADDRESS,PCR     ; Get address of op code
0290                                                         ; If it is a page2/3 instruction, op code is the next byte after ADDRESS
0291 310c 7d 10 14                   tst     PAGE23          ; Page2/3 instruction?
0292 310f 27 04                      beq     norm            ; Branch if not
0293 3111 a6 02                      lda     2,x             ; Post byte is two past ADDRESS
0294 3113 20 02                      bra     getpb
0295 3115 a6 01              norm    lda     1,x             ; Get next byte (the post byte)
0296 3117 b7 10 15           getpb   sta     POSTBYT         ; Save it
0297                         
0298                         ; Determine number of additional bytes for indexed addressing based on
0299                         ; postbyte. If most significant bit is 0, there are no additional
0300                         ; bytes and we can skip the rest of the check.
0301                         
0302 311a 2a 0e                      bpl     NotIndexed      ; Branch of MSB is zero
0303                         
0304                         ; Else if most significant bit is 1, mask off all but low order 5 bits
0305                         ; and look up length in table.
0306                         
0307 311c 84 1f                      anda    #%00011111      ; Mask off bits
0308 311e 30 8d 97 c6                leax    POSTBYTES,PCR   ; Lookup table of lengths
0309 3122 a6 86                      lda     a,x             ; Get table entry
0310 3124 bb 10 16                   adda    LENGTH          ; Add to instruction length
0311 3127 b7 10 16                   sta     LENGTH          ; Save new length
0312                         
0313                         NotIndexed
0314                         
0315                         ; At this point we have set: ADDRESS, OPCODE, OPTYPE, LENGTH, AM, PAGE23, POSTBYT
0316                         ; Now check for special instructions that change flow of control or otherwise
0317                         ; need special handling rather than being directly executed.
0318                         
0319                         ; Invalid op code?
0320 312a b6 10 13                   lda     OPTYPE          ; Get op code type
0321 312d 81 00                      cmpa    #OP_INV         ; Is it an invalid instruction?
0322 312f 10 27 05 ae                lbeq    update          ; If so, nothing to do (length is 1 byte)
0323                         
0324                         ; Check for PC relative indexed addressing modes that we don't
0325                         ; currently handle. If so, display a warning but still trace the
0326                         ; instruction.
0327                         
0328 3133 b6 10 17                   lda    AM               ; Get address mode
0329 3136 81 08                      cmpa   #AM_INDEXED      ; Indexed addressing
0330 3138 26 13                      bne    trysync          ; Branch if not
0331 313a b6 10 15                   lda    POSTBYT          ; Get the post byte
0332                         
0333                         ; It is a PCR mode if the post byte has the pattern 1xxx110x
0334                         
0335 313d 84 8e                      anda   #%10001110       ; Mask bits we want to check
0336 313f 81 8c                      cmpa   #%10001100       ; Check for pattern
0337 3141 26 0a                      bne    trysync          ; Branch if no match
0338                         
0339                         ; Display "Warning: instruction not supported, expect incorrect results."
0340                         
0341 3143 30 8d 06 8d                leax    MSG12,PCR       ; Message string
0342 3147 17 8f 53                   lbsr    PrintString     ; Display it
0343 314a 17 8e e1                   lbsr    PrintCR
0344                         
0345                         ; SYNC instruction. Continue (emulate interrupt and then RTI
0346                         ; happenning or mask interrupt and instruction continuing).
0347                         
0348 314d b6 10 13           trysync lda     OPTYPE          ; Get op code type
0349 3150 81 80                      cmpa    #OP_SYNC        ; Is it a SYNC instruction?
0350 3152 10 27 05 8b                lbeq    update          ; If so, nothing to do (length is 1 byte)
0351                         
0352                         ; CWAI #$XX instruction. AND operand with CC. Set E flag in CC. Continue (emulate interrupt and then RTI happenning).
0353                         
0354 3156 b6 10 13                   lda     OPTYPE          ; Get op code type
0355 3159 81 30                      cmpa    #OP_CWAI        ; Is it a CWAI instruction?
0356 315b 26 10                      bne     tryswi
0357 315d be 10 0e                   ldx     ADDRESS         ; Get address of instruction
0358 3160 a6 01                      lda     1,x             ; Get operand
0359 3162 8a 80                      ora     #%10000000      ; Set E bit
0360 3164 ba 10 00                   ora     SAVE_CC         ; Or with CC
0361 3167 b7 10 00                   sta     SAVE_CC         ; Save CC
0362 316a 16 05 74                   lbra    update          ; Done
0363                         
0364                         ; SWI instruction. Increment PC. Save all registers except S on hardware stack.
0365                         ; Set I and F in CC. Set new PC to [FFFA,FFFB].
0366                         
0367 316d 81 7d              tryswi  cmpa    #OP_SWI
0368 316f 26 4e                      bne     tryswi2
0369 3171 be 10 0e                   ldx     ADDRESS         ; Get address of instruction
0370 3174 30 01                      leax    1,x             ; Add one
0371 3176 bf 10 0c                   stx     SAVE_PC         ; Save new PC
0372                         
0373                         ; push CC, A, B, DP, X, Y, U, PC
0374                         
0375 3179 10 ff 10 18                sts     OURS            ; Save our SP
0376 317d 10 fe 10 0a                lds     SAVE_S          ; Use program's SP to push
0377                         
0378 3181 b6 10 00                   lda     SAVE_CC
0379 3184 34 02                      pshs    a
0380 3186 8a 50                      ora     #%01010000      ; Set I and F bits
0381 3188 b7 10 00                   sta     SAVE_CC
0382 318b b6 10 01                   lda     SAVE_A
0383 318e 34 02                      pshs    a
0384 3190 b6 10 02                   lda     SAVE_B
0385 3193 34 02                      pshs    a
0386 3195 b6 10 03                   lda     SAVE_DP
0387 3198 34 02                      pshs    a
0388 319a be 10 04                   ldx     SAVE_X
0389 319d 34 10                      pshs    x
0390 319f be 10 06                   ldx     SAVE_Y
0391 31a2 34 10                      pshs    x
0392 31a4 be 10 08                   ldx     SAVE_U
0393 31a7 34 10                      pshs    x
0394 31a9 be 10 0c                   ldx     SAVE_PC
0395 31ac 34 10                      pshs    x
0396 31ae 10 ff 10 0a                sts     SAVE_S          ; Save new value of SP
0397 31b2 10 fe 10 18                lds     OURS            ; Restore our SP
0398                         
0399 31b6 be ff fa                   ldx     $FFFA           ; Get address of SWI vector
0400 31b9 bf 10 0e                   stx     ADDRESS         ; Set as new address
0401                         
0402 31bc 16 05 2c                   lbra    done            ; Done
0403                         
0404                         ; SWI2 instruction. Increment PC. Save all registers except S on
0405                         ; stack. Set new PC to [FFF4,FFF5].
0406                         
0407 31bf 81 7e              tryswi2 cmpa    #OP_SWI2
0408 31c1 26 49                      bne     tryswi3
0409 31c3 be 10 0e                   ldx     ADDRESS         ; Get address of instruction
0410 31c6 30 01                      leax    1,x             ; Add one
0411 31c8 bf 10 0c                   stx     SAVE_PC         ; Save new PC
0412                         
0413                         ; push CC, A, B, DP, X, Y, U, PC
0414                         
0415 31cb 10 ff 10 18                sts     OURS            ; Save our SP
0416 31cf 10 fe 10 0a                lds     SAVE_S          ; Use program's SP to push
0417                         
0418 31d3 b6 10 00                   lda     SAVE_CC
0419 31d6 34 02                      pshs    a
0420 31d8 b6 10 01                   lda     SAVE_A
0421 31db 34 02                      pshs    a
0422 31dd b6 10 02                   lda     SAVE_B
0423 31e0 34 02                      pshs    a
0424 31e2 b6 10 03                   lda     SAVE_DP
0425 31e5 34 02                      pshs    a
0426 31e7 be 10 04                   ldx     SAVE_X
0427 31ea 34 10                      pshs    x
0428 31ec be 10 06                   ldx     SAVE_Y
0429 31ef 34 10                      pshs    x
0430 31f1 be 10 08                   ldx     SAVE_U
0431 31f4 34 10                      pshs    x
0432 31f6 be 10 0c                   ldx     SAVE_PC
0433 31f9 34 10                      pshs    x
0434 31fb 10 ff 10 0a                sts     SAVE_S          ; Save new value of SP
0435 31ff 10 fe 10 18                lds     OURS            ; Restore our SP
0436                         
0437 3203 be ff f4                   ldx     $FFF4           ; Get address of SWI2 vector
0438 3206 bf 10 0e                   stx     ADDRESS         ; Set as new address
0439                         
0440 3209 16 04 df                   lbra    done            ; Done
0441                         
0442                         ; SWI3 instruction. Increment PC. Save all registers except S on
0443                         ; stack. Set new PC to [FFF2,FFF3].
0444                         
0445 320c 81 7f              tryswi3 cmpa    #OP_SWI3
0446 320e 26 49                      bne     tryjmp
0447 3210 be 10 0e                   ldx     ADDRESS         ; Get address of instruction
0448 3213 30 01                      leax    1,x             ; Add one
0449 3215 bf 10 0c                   stx     SAVE_PC         ; Save new PC
0450                         
0451                         ; push CC, A, B, DP, X, Y, U, PC
0452                         
0453 3218 10 ff 10 18                sts     OURS            ; Save our SP
0454 321c 10 fe 10 0a                lds     SAVE_S          ; Use program's SP to push
0455                         
0456 3220 b6 10 00                   lda     SAVE_CC
0457 3223 34 02                      pshs    a
0458 3225 b6 10 01                   lda     SAVE_A
0459 3228 34 02                      pshs    a
0460 322a b6 10 02                   lda     SAVE_B
0461 322d 34 02                      pshs    a
0462 322f b6 10 03                   lda     SAVE_DP
0463 3232 34 02                      pshs    a
0464 3234 be 10 04                   ldx     SAVE_X
0465 3237 34 10                      pshs    x
0466 3239 be 10 06                   ldx     SAVE_Y
0467 323c 34 10                      pshs    x
0468 323e be 10 08                   ldx     SAVE_U
0469 3241 34 10                      pshs    x
0470 3243 be 10 0c                   ldx     SAVE_PC
0471 3246 34 10                      pshs    x
0472 3248 10 ff 10 0a                sts     SAVE_S          ; Save new value of SP
0473 324c 10 fe 10 18                lds     OURS            ; Restore our SP
0474                         
0475 3250 be ff f2                   ldx     $FFF2           ; Get address of SWI3 vector
0476 3253 bf 10 0e                   stx     ADDRESS         ; Set as new address
0477                         
0478 3256 16 04 92                   lbra    done            ; Done
0479                         
0480                         ; JMP instruction. Next PC is operand effective address. Need to
0481                         ; handle extended, direct, and indexed modes.
0482                         
0483 3259 81 3b              tryjmp  cmpa    #OP_JMP         ; Is it a JMP instruction?
0484 325b 10 26 00 84                lbne    tryjsr          ; Branch if not.
0485 325f b6 10 12                   lda     OPCODE          ; Get the actual op code
0486 3262 81 7e                      cmpa    #$7E            ; Extended, e.g. JMP $XXXX ?
0487 3264 26 0e                      bne     jmp1
0488 3266 be 10 0e                   ldx     ADDRESS         ; Get address of instruction
0489 3269 ae 01                      ldx     1,x             ; Get 16-bit operand (JMP destination)
0490 326b bf 10 0e                   stx     ADDRESS         ; Set as new instruction address
0491 326e bf 10 0c                   stx     SAVE_PC
0492 3271 16 04 77                   lbra    done            ; Done
0493                         
0494 3274 81 0e              jmp1    cmpa    #$0E            ; Direct, e.g. JMP $XX ?
0495 3276 26 11                      bne     jmp2
0496 3278 be 10 0e                   ldx     ADDRESS         ; Get address of instruction
0497 327b e6 01                      ldb     1,x             ; Get 8-bit operand (JMP destination)
0498 327d b6 10 03                   lda     SAVE_DP         ; Get DP register
0499 3280 fd 10 0e                   std     ADDRESS         ; Full address is DP (in A) + operand (in B)
0500 3283 fd 10 0c                   std     SAVE_PC
0501 3286 16 04 62                   lbra    done            ; Done
0502                         
0503                         ; Must be indexed, e.g. JMP 1,X. Can't get effective address directly
0504                         ; from instruction. Instead we use this trick: Run a LEAU instruction
0505                         ; with the same indexed operand. Then examine value of X, which should
0506                         ; be the new PC. Need to run it with the current index register values
0507                         ; of X, Y, U, and S.
0508                         ; TODO: Not handled: addressing modes that change U register like JMP ,U++.
0509                         ; TODO: Not handled correctly: PCR modes like JMP 10,PCR
0510                         
0511 3289 be 10 0e           jmp2    ldx     ADDRESS         ; Address of instruction
0512 328c 10 8e 10 1c                ldy     #BUFFER         ; Address of buffer
0513 3290 c6 33                      ldb     #$33            ; LEAU instruction
0514 3292 4f                         clra                    ; Loop counter and index
0515 3293 e7 a6                      stb     a,y             ; Write LEAU instruction to buffer
0516 3295 4c                         inca                    ; Move to next byte
0517 3296 e6 86              copy1   ldb     a,x             ; Get instruction byte
0518 3298 e7 a6                      stb     a,y             ; Write to buffer
0519 329a 4c                         inca                    ; Increment counter
0520 329b b1 10 16                   cmpa    LENGTH          ; Copied all bytes?
0521 329e 26 f6                      bne     copy1
0522                         
0523                         ; Add a jump after the instruction to where we want to go after it is executed (ReturnFromJump).
0524                         
0525 32a0 c6 7e                      ldb     #$7E            ; JMP $XXXX instruction
0526 32a2 e7 a6                      stb     a,y             ; Store in buffer
0527 32a4 4c                         inca                    ; Advance buffer
0528 32a5 8e 32 c8                   ldx     #ReturnFromJump ; Destination address of JMP
0529 32a8 af a6                      stx     a,y             ; Store in buffer
0530                         
0531                         ; Restore registers from saved values.
0532                         
0533 32aa 10 ff 10 18                sts     OURS            ; Save this program's stack pointers
0534 32ae ff 10 1a                   stu     OURU
0535                         
0536 32b1 b6 10 01                   lda     SAVE_A
0537 32b4 f6 10 02                   ldb     SAVE_B
0538 32b7 be 10 04                   ldx     SAVE_X
0539 32ba 10 be 10 06                ldy     SAVE_Y
0540 32be 10 fe 10 0a                lds     SAVE_S
0541 32c2 fe 10 08                   ldu     SAVE_U
0542                         
0543                         ; Call instruction in buffer. It is followed by a JMP ReturnFromJump so we get back.
0544                         
0545 32c5 7e 10 1c                   jmp     BUFFER
0546                         
0547                         ReturnFromJump
0548                         
0549                         ; Restore saved registers (except U and PC).
0550                         
0551 32c8 bf 10 04                   stx     SAVE_X
0552 32cb 10 bf 10 06                sty     SAVE_Y
0553 32cf 10 ff 10 0a                sts     SAVE_S
0554                         
0555                         ; Restore this program's stack pointers so RTS etc. will still work.
0556                         
0557 32d3 10 fe 10 18                lds     OURS
0558 32d7 fe 10 1a                   ldu     OURU
0559                         
0560                         ; Value of X is new PC
0561                         
0562 32da bf 10 0e                   stx     ADDRESS         ; Set as new instruction address
0563 32dd bf 10 0c                   stx     SAVE_PC
0564 32e0 16 04 08                   lbra    done            ; Done
0565                         
0566                         ; JSR instruction. Next PC is operand effective address. Push return
0567                         ; address on stack. Need to handle extended, direct, and indexed
0568                         ; modes.
0569                         
0570 32e3 81 3c              tryjsr  cmpa    #OP_JSR         ; Is it a JSR instruction?
0571 32e5 10 26 00 78                lbne    tryrts          ; Branch if not.
0572 32e9 b6 10 12                   lda     OPCODE          ; Get the actual op code
0573 32ec 81 bd                      cmpa    #$BD            ; Extended, e.g. JSR $XXXX ?
0574 32ee 26 27                      bne     jsr1
0575                         
0576 32f0 4f                         clra                    ; Set MSB to zero
0577 32f1 f6 10 16                   ldb     LENGTH          ; Get instruction length (byte)
0578 32f4 f3 10 0e                   addd    ADDRESS         ; 16-bit add
0579                         
0580 32f7 10 ff 10 18                sts     OURS            ; Save this program's stack pointer
0581 32fb 10 fe 10 0a                lds     SAVE_S          ; Get program's stack pointer
0582 32ff 34 06                      pshs    d               ; Push return address
0583 3301 10 ff 10 0a                sts     SAVE_S          ; Save program's new stack pointer
0584 3305 10 fe 10 18                lds     OURS            ; Restore our stack pointer
0585                         
0586 3309 be 10 0e                   ldx     ADDRESS         ; Get address of instruction
0587 330c ae 01                      ldx     1,x             ; Get 16-bit operand (JSR destination)
0588 330e bf 10 0e                   stx     ADDRESS         ; Set as new instruction address
0589 3311 bf 10 0c                   stx     SAVE_PC
0590 3314 16 03 d4                   lbra    done            ; Done
0591                         
0592 3317 81 9d              jsr1    cmpa    #$9D            ; Direct, e.g. JSR $XX ?
0593 3319 26 2a                      bne     jsr2
0594                         
0595 331b 4f                         clra                    ; Set MSB to zero
0596 331c f6 10 16                   ldb     LENGTH          ; Get instruction length (byte)
0597 331f f3 10 0e                   addd    ADDRESS         ; 16-bit add
0598                         
0599 3322 10 ff 10 18                sts     OURS            ; Save this program's stack pointer
0600 3326 10 fe 10 0a                lds     SAVE_S          ; Get program's stack pointer
0601 332a 34 06                      pshs    d               ; Push return address
0602 332c 10 ff 10 0a                sts     SAVE_S          ; Save program's new stack pointer
0603 3330 10 fe 10 18                lds     OURS            ; Restore our stack pointer
0604                         
0605 3334 be 10 0e                   ldx     ADDRESS         ; Get address of instruction
0606 3337 e6 01                      ldb     1,x             ; Get 8-bit operand (JSR destination)
0607 3339 b6 10 03                   lda     SAVE_DP         ; Get DP register
0608 333c fd 10 0e                   std     ADDRESS         ; Full address is DP (in A) + operand (in B)
0609 333f fd 10 0c                   std     SAVE_PC
0610 3342 16 03 a6                   lbra    done            ; Done
0611                         
0612                         ; Must be indexed, e.g. JSR 1,X. Use same LEAU trick as for JMP.
0613                         ; TODO: Not handled: addressing modes that change U register like JSR ,U++.
0614                         ; TODO: Not handled correctly: PCR modes like JSR 10,PCR
0615                         
0616 3345 4f                 jsr2    clra                    ; Set MSB to zero
0617 3346 f6 10 16                   ldb     LENGTH          ; Get instruction length (byte)
0618 3349 f3 10 0e                   addd    ADDRESS         ; 16-bit add
0619                         
0620 334c 10 ff 10 18                sts     OURS            ; Save this program's stack pointer
0621 3350 10 fe 10 0a                lds     SAVE_S          ; Get program's stack pointer
0622 3354 34 06                      pshs    d               ; Push return address
0623 3356 10 ff 10 0a                sts     SAVE_S          ; Save program's new stack pointer
0624 335a 10 fe 10 18                lds     OURS            ; Restore our stack pointer
0625                         
0626 335e 16 ff 28                   lbra    jmp2            ; Rest of code is shared with JMP routine
0627                         
0628                         ; RTS instruction. Pop PC from stack and set it to next address.
0629                         
0630 3361 81 6f              tryrts  cmpa    #OP_RTS         ; Is it a RTS instruction?
0631 3363 26 1b                      bne     tryrti          ; Branch if not.
0632 3365 10 ff 10 18                sts     OURS            ; Save this program's stack pointer
0633 3369 10 fe 10 0a                lds     SAVE_S          ; Get program's stack pointer
0634 336d 35 10                      puls    x               ; Pull return address
0635 336f 10 ff 10 0a                sts     SAVE_S          ; Save program's new stack pointer
0636 3373 10 fe 10 18                lds     OURS            ; Restore our stack pointer
0637 3377 bf 10 0e                   stx     ADDRESS         ; Set as new instruction address
0638 337a bf 10 0c                   stx     SAVE_PC
0639 337d 16 03 6b                   lbra    done            ; Done
0640                         
0641                         ; RTI instruction.
0642                         ; If E flag is not set, pop PC and CC.
0643                         ; If E flag is set, pop PC, U, Y, X, DP, B, A, and CC.
0644                         ; Set next instruction to PC.
0645                         
0646 3380 81 6e              tryrti  cmpa    #OP_RTI         ; Is it a RTI instruction?
0647 3382 26 43                      bne     trybsr          ; Branch if not.
0648 3384 10 ff 10 18                sts     OURS            ; Save this program's stack pointer
0649 3388 10 fe 10 0a                lds     SAVE_S          ; Get program's stack pointer
0650 338c 35 10                      puls    x               ; Pull PC
0651 338e bf 10 0e                   stx     ADDRESS         ; Set as new instruction address
0652 3391 bf 10 0c                   stx     SAVE_PC
0653                         
0654 3394 b6 10 00                   lda     SAVE_CC         ; Test CC
0655 3397 2a 1e                      bpl     notEntire       ; Branch if Entire bit (MSB is not set)
0656 3399 35 10                      puls    x               ; Pull U
0657 339b bf 10 08                   stx     SAVE_U
0658 339e 35 10                      puls    x               ; Pull Y
0659 33a0 bf 10 06                   stx     SAVE_Y
0660 33a3 35 10                      puls    x               ; Pull X
0661 33a5 bf 10 04                   stx     SAVE_X
0662 33a8 35 02                      puls    a               ; Pull DP
0663 33aa b7 10 03                   sta     SAVE_DP
0664 33ad 35 02                      puls    a               ; Pull B
0665 33af b7 10 02                   sta     SAVE_B
0666 33b2 35 02                      puls    a               ; Pull A
0667 33b4 b7 10 01                   sta     SAVE_A
0668                         notEntire
0669 33b7 35 02                      puls    a               ; Pull CC
0670 33b9 b7 10 00                   sta     SAVE_CC
0671                         
0672 33bc 10 ff 10 0a                sts     SAVE_S          ; Save program's new stack pointer
0673 33c0 10 fe 10 18                lds     OURS            ; Restore our stack pointer
0674 33c4 16 03 24                   lbra    done            ; Done
0675                         
0676                         ; BSR instruction. Similar to JSR but EA is relative.
0677                         
0678 33c7 81 20              trybsr  cmpa    #OP_BSR         ; Is it a BSR instruction?
0679 33c9 26 2f                      bne     trylbsr         ; Branch if not.
0680                         
0681                         ; Push return address on stack.
0682                         
0683 33cb 4f                         clra                    ; Set MSB to zero
0684 33cc f6 10 16                   ldb     LENGTH          ; Get instruction length (byte)
0685 33cf f3 10 0e                   addd    ADDRESS         ; 16-bit add
0686                         
0687 33d2 10 ff 10 18                sts     OURS            ; Save this program's stack pointer
0688 33d6 10 fe 10 0a                lds     SAVE_S          ; Get program's stack pointer
0689 33da 34 06                      pshs    d               ; Push return address
0690 33dc 10 ff 10 0a                sts     SAVE_S          ; Save program's new stack pointer
0691 33e0 10 fe 10 18                lds     OURS            ; Restore our stack pointer
0692                         
0693                         ; Next PC is PC plus instruction length (2) plus offset operand.
0694                         
0695 33e4 be 10 0e                   ldx     ADDRESS         ; Get address of instruction
0696 33e7 4f                         clra                    ; Clear MSB
0697 33e8 e6 01                      ldb     1,x             ; Get 8-bit signed branch offset
0698 33ea 1d                         sex                     ; Sign extend to 16-bits
0699 33eb c3 00 02                   addd    #2              ; Add instruction length (2)
0700 33ee f3 10 0e                   addd    ADDRESS         ; Add to address
0701 33f1 fd 10 0e                   std     ADDRESS         ; Store new address value
0702 33f4 fd 10 0c                   std     SAVE_PC
0703 33f7 16 02 f1                   lbra    done            ; Done
0704                         
0705                         ; LBSR instruction. Similar to BSR above.
0706                         
0707 33fa 81 4b              trylbsr cmpa    #OP_LBSR        ; Is it a LBSR instruction?
0708 33fc 26 2d                      bne     trybxx          ; Branch if not.
0709                         
0710                         ; Push return address on stack.
0711                         
0712 33fe 4f                         clra                    ; Set MSB to zero
0713 33ff f6 10 16                   ldb     LENGTH          ; Get instruction length (byte)
0714 3402 f3 10 0e                   addd    ADDRESS         ; 16-bit add
0715                         
0716 3405 10 ff 10 18                sts     OURS            ; Save this program's stack pointer
0717 3409 10 fe 10 0a                lds     SAVE_S          ; Get program's stack pointer
0718 340d 34 06                      pshs    d               ; Push return address
0719 340f 10 ff 10 0a                sts     SAVE_S          ; Save program's new stack pointer
0720 3413 10 fe 10 18                lds     OURS            ; Restore our stack pointer
0721                         
0722                         ; Next PC is PC plus instruction length (3) plus 16-bit offset operand.
0723                         
0724 3417 be 10 0e                   ldx     ADDRESS         ; Get address of instruction
0725 341a ec 01                      ldd     1,x             ; Get 16-bit signed branch offset
0726 341c c3 00 03                   addd    #3              ; Add instruction length (3)
0727 341f f3 10 0e                   addd    ADDRESS         ; Add to address
0728 3422 fd 10 0e                   std     ADDRESS         ; Store new address value
0729 3425 fd 10 0c                   std     SAVE_PC
0730 3428 16 02 c0                   lbra    done            ; Done
0731                         
0732                         ; Bxx instructions.
0733                         ; These are executed but we change the destination of the branch so we
0734                         ; catch whether they are taken or not.
0735                         ; The code in the buffer will look like this:
0736                         ;
0737                         ;       JMP BUFFER
0738                         ;       ...
0739                         ; XXXX XX 03           Bxx $03 (Taken)         ; Instruction being traced
0740                         ; XXXX 7E XX XX        JMP BranchNotTaken
0741                         ; XXXX 7E XX XX Taken  JMP BranchTaken
0742                         ;        ...
0743                         ;
0744                         ; If we come back via BranchNotTaken, next PC is instruction after the branch (PC plus 2).
0745                         ; If we come back via BranchTaken, next PC is PC plus offset plus 2.
0746                         ; Need to set CC to program's value before the branch is executed.
0747                         
0748 342b b6 10 17           trybxx  lda     AM              ; Get addressing mode
0749 342e 81 06                      cmpa    #AM_RELATIVE8   ; Is it a relative branch?
0750 3430 26 4e                      bne     trylbxx
0751                         
0752 3432 be 10 0e                   ldx     ADDRESS         ; Address of instruction
0753 3435 10 8e 10 1c                ldy     #BUFFER         ; Address of buffer
0754 3439 a6 84                      lda     ,x              ; Get branch instruction
0755 343b a7 a4                      sta     ,y              ; Store in buffer
0756 343d 86 03                      lda     #3              ; Branch offset (Taken)
0757 343f a7 21                      sta     1,y             ; Store in buffer
0758 3441 86 7e                      lda     #$7E            ; JMP $XXXX instruction
0759 3443 a7 22                      sta     2,y             ; Store in buffer
0760 3445 8e 34 71                   ldx     #BranchNotTaken ; Address for branch
0761 3448 af 23                      stx     3,y             ; Store in buffer
0762 344a 86 7e                      lda     #$7E            ; JMP $XXXX instruction
0763 344c a7 25                      sta     5,y             ; Store in buffer
0764 344e 8e 34 5b                   ldx     #BranchTaken    ; Address for branch
0765 3451 af 26                      stx     6,y             ; Store in buffer
0766                         
0767                         ; Restore CC from saved value.
0768                         
0769 3453 b6 10 00                   lda     SAVE_CC
0770 3456 1f 8a                      tfr     a,cc
0771                         
0772                         ; Call instruction in buffer. It is followed by a JMP so we get back.
0773                         
0774 3458 7e 10 1c                   jmp     BUFFER
0775                         
0776                         BranchTaken                     ; Next PC is PC plus offset plus 2.
0777                         
0778 345b be 10 0e                   ldx     ADDRESS         ; Get address of instruction
0779 345e 4f                         clra                    ; Clear MSB
0780 345f e6 01                      ldb     1,x             ; Get 8-bit signed branch offset
0781 3461 1d                         sex                     ; Sign extend to 16-bits
0782 3462 c3 00 02                   addd    #2              ; Add instruction length (2)
0783 3465 f3 10 0e                   addd    ADDRESS         ; Add to address
0784 3468 fd 10 0e                   std     ADDRESS         ; Store new address value
0785 346b fd 10 0c                   std     SAVE_PC
0786 346e 16 02 7a                   lbra    done            ; Done
0787                         
0788                         BranchNotTaken                  ; Next PC is instruction after the branch (PC plus 2).
0789                         
0790 3471 fc 10 0e                   ldd     ADDRESS         ; Get address of instruction
0791 3474 c3 00 02                   addd    #2              ; Add instruction length (2)
0792 3477 fd 10 0e                   std     ADDRESS         ; Store new address value
0793 347a fd 10 0c                   std     SAVE_PC
0794 347d 16 02 6b                   lbra    done            ; Done
0795                         
0796                         ; LBxx instructions. Similar to Bxx above.
0797                         
0798 3480 81 07              trylbxx cmpa    #AM_RELATIVE16  ; Is it a long relative branch?
0799 3482 10 26 00 8b                lbne    trytfr
0800                         
0801                         ; Note Long branch instructions are 4 bytes (prefixed by 10) except
0802                         ; LBRA which is only 3 bytes.
0803                         ; BUFFER in this case is:
0804                         ; XXXX 16 00 03        LBRA $0003 (Taken)   ; Instruction being traced
0805                         ; XXXX 7E XX XX        JMP  BranchNotTaken1
0806                         ; XXX  7E XX XX Taken  JMP  BranchTaken1
0807                         ;
0808                         ; Or:
0809                         ;
0810                         ; XXXX 10 XX 00 03       LBxx $0003 (Taken) ; Instruction being traced
0811                         ; XXXX 7E XX XX          JMP  BranchNotTaken1
0812                         ; XXXX 7E XX XX   Taken  JMP  BranchTaken1
0813                         
0814 3486 b6 10 12                   lda     OPCODE          ; Get  opcode
0815 3489 81 16                      cmpa    #$16            ; Is it LBRA?
0816 348b 26 24                      bne     long            ; Branch if it is one of the other 4 byte instructions
0817                                 
0818 348d be 10 0e                   ldx     ADDRESS         ; Address of instruction
0819 3490 10 8e 10 1c                ldy     #BUFFER         ; Address of buffer
0820 3494 a6 84                      lda     ,x              ; Get branch instruction
0821 3496 a7 a4                      sta     ,y              ; Store in buffer
0822 3498 8e 00 03                   ldx     #3              ; Branch offset (Taken)
0823 349b af 21                      stx     1,y             ; Store in buffer
0824 349d 86 7e                      lda     #$7E            ; JMP $XXXX instruction
0825 349f a7 23                      sta     3,y             ; Store in buffer
0826 34a1 8e 35 00                   ldx     #BranchNotTaken1 ; Address for branch
0827 34a4 af 24                      stx     4,y             ; Store in buffer
0828 34a6 86 7e                      lda     #$7E            ; JMP $XXXX instruction
0829 34a8 a7 26                      sta     6,y             ; Store in buffer
0830 34aa 8e 34 db                   ldx     #BranchTaken1   ; Address for branch
0831 34ad af 27                      stx     7,y             ; Store in buffer
0832 34af 20 22                      bra     branch
0833                         
0834 34b1 be 10 0e           long    ldx     ADDRESS         ; Address of instruction
0835 34b4 10 8e 10 1c                ldy     #BUFFER         ; Address of buffer
0836 34b8 ae 84                      ldx     ,x              ; Get two byte branch instruction
0837 34ba af a4                      stx     ,y              ; Store in buffer
0838 34bc 8e 00 03                   ldx     #3              ; Branch offset (Taken)
0839 34bf af 22                      stx     2,y             ; Store in buffer
0840 34c1 86 7e                      lda     #$7E            ; JMP $XXXX instruction
0841 34c3 a7 24                      sta     4,y             ; Store in buffer
0842 34c5 8e 35 00                   ldx     #BranchNotTaken1 ; Address for branch
0843 34c8 af 25                      stx     5,y             ; Store in buffer
0844 34ca 86 7e                      lda     #$7E            ; JMP $XXXX instruction
0845 34cc a7 27                      sta     7,y             ; Store in buffer
0846 34ce 8e 34 db                   ldx     #BranchTaken1   ; Address for branch
0847 34d1 af 28                      stx     8,y             ; Store in buffer
0848                         
0849                         ; Restore CC from saved value.
0850                         
0851 34d3 b6 10 00           branch  lda     SAVE_CC
0852 34d6 1f 8a                      tfr     a,cc
0853                         
0854                         ; Call instruction in buffer. It is followed by a JMP so we get back.
0855                         
0856 34d8 7e 10 1c                   jmp     BUFFER
0857                         
0858                         BranchTaken1                    ; Next PC is PC plus offset plus instruction length (3 or 4)
0859                         
0860                         ; Offset is 1,X for LBRA (2 byte instruction) and 2,X for others (3 byte instructions)
0861                         
0862 34db be 10 0e                   ldx     ADDRESS
0863 34de b6 10 12                   lda     OPCODE          ; Get  opcode
0864 34e1 81 16                      cmpa    #$16            ; Is it LBRA?
0865 34e3 26 0a                      bne     long1           ; Branch if it is one of the other 4 byte instructions
0866                         
0867 34e5 fc 10 0e                   ldd     ADDRESS         ; Get address
0868 34e8 c3 00 03                   addd    #3              ; Plus 3
0869 34eb e3 01                      addd    1,x             ; Add 16-bit signed branch offset
0870 34ed 20 08                      bra     upd
0871                         
0872 34ef fc 10 0e           long1   ldd     ADDRESS         ; Get address
0873 34f2 c3 00 04                   addd    #4              ; Plus 4
0874 34f5 e3 02                      addd    2,x             ; Add 16-bit signed branch offset
0875                         
0876 34f7 fd 10 0e           upd     std     ADDRESS         ; Store new address value
0877 34fa fd 10 0c                   std     SAVE_PC
0878 34fd 16 01 eb                   lbra    done            ; Done
0879                         
0880                         BranchNotTaken1                 ; Next PC is instruction after the branch (PC plus 3 or 4).
0881                         
0882 3500 4f                         clra                    ; Clear MSB
0883 3501 f6 10 16                   ldb     LENGTH          ; Get instruction length
0884 3504 1d                         sex                     ; Sign extend to 16 bits
0885 3505 f3 10 0e                   addd    ADDRESS         ; Add instruction address
0886 3508 fd 10 0e                   std     ADDRESS         ; Store new address value
0887 350b fd 10 0c                   std     SAVE_PC
0888 350e 16 01 da                   lbra    done            ; Done
0889                         
0890                         ; Handle TFR instruction.
0891                         ; Need to manually handle cases where source or destination is the PC
0892                         ; since it won't run correctly from the buffer.
0893                         
0894 3511 b6 10 12           trytfr  lda     OPCODE          ; Get the actual op code
0895 3514 81 1f                      cmpa    #$1F            ; Is it TFR R1,R2 ?
0896 3516 10 26 00 94                lbne    tryexg          ; Branch if not
0897 351a be 10 0e                   ldx     ADDRESS         ; Get address of instruction
0898 351d a6 01                      lda     1,x             ; Get operand byte
0899 351f 84 f0                      anda    #%11110000      ; Mask source bits
0900 3521 81 50                      cmpa    #%01010000      ; Is source register PC?
0901 3523 26 44                      bne     checkdest       ; Branch if not
0902                         
0903 3525 10 be 10 0e                ldy     ADDRESS         ; Get current PC
0904 3529 31 22                      leay    2,y             ; Add instruction length
0905                         
0906 352b a6 01                      lda     1,x             ; Get operand byte
0907 352d 84 0f                      anda    #%00001111      ; Mask destination bits
0908 352f 81 00                      cmpa    #%00000000      ; D?
0909 3531 27 13                      beq     to_d
0910 3533 81 01                      cmpa    #%00000001      ; X?
0911 3535 27 16                      beq     to_x
0912 3537 81 02                      cmpa    #%00000010      ; Y?
0913 3539 27 19                      beq     to_y
0914 353b 81 03                      cmpa    #%00000011      ; U?
0915 353d 27 1c                      beq     to_u
0916 353f 81 04                      cmpa    #%00000100      ; S?
0917 3541 27 1f                      beq     to_s
0918 3543 16 01 9b                   lbra    update          ; Anything else is invalid or PC to PC, so ignore
0919                         
0920 3546 10 bf 10 01        to_d    sty     SAVE_D          ; Write new PC to D
0921 354a 16 01 94                   lbra    update          ; Done
0922 354d 10 bf 10 04        to_x    sty     SAVE_X          ; Write new PC to X
0923 3551 16 01 8d                   lbra    update          ; Done
0924 3554 10 bf 10 06        to_y    sty     SAVE_Y          ; Write new PC to Y
0925 3558 16 01 86                   lbra    update          ; Done
0926 355b 10 bf 10 08        to_u    sty     SAVE_U          ; Write new PC to U
0927 355f 16 01 7f                   lbra    update          ; Done
0928 3562 10 bf 10 0a        to_s    sty     SAVE_S          ; Write new PC to S
0929 3566 16 01 78                   lbra    update          ; Done
0930                         
0931                         checkdest
0932 3569 a6 01                      lda     1,x             ; Get operand byte
0933 356b 84 0f                      anda    #%00001111      ; Mask destination bits
0934 356d 81 05                      cmpa    #%00000101      ; Is destination register PC?
0935 356f 10 26 00 fe                lbne    norml           ; Branch to normal instruction handling if not
0936                         
0937 3573 a6 01                      lda     1,x             ; Get operand byte
0938 3575 84 f0                      anda    #%11110000      ; Mask source bits
0939 3577 81 00                      cmpa    #%00000000      ; D?
0940 3579 27 13                      beq     from_d
0941 357b 81 10                      cmpa    #%00010000      ; X?
0942 357d 27 14                      beq     from_x
0943 357f 81 20                      cmpa    #%00100000      ; Y?
0944 3581 27 15                      beq     from_y
0945 3583 81 30                      cmpa    #%00110000      ; U?
0946 3585 27 16                      beq     from_u
0947 3587 81 40                      cmpa    #%01000000      ; S?
0948 3589 27 17                      beq     from_s
0949 358b 16 01 53                   lbra    update          ; Anything else is invalid or PC to PC, so ignore
0950                         
0951 358e be 10 01           from_d  ldx     SAVE_D          ; Get D
0952 3591 20 12                      bra     write
0953 3593 be 10 04           from_x  ldx     SAVE_X          ; Get X
0954 3596 20 0d                      bra     write
0955 3598 be 10 06           from_y  ldx     SAVE_Y          ; Get Y
0956 359b 20 08                      bra     write
0957 359d be 10 08           from_u  ldx     SAVE_U          ; Get U
0958 35a0 20 03                      bra     write
0959 35a2 be 10 0a           from_s  ldx     SAVE_S          ; Get S
0960                         
0961 35a5 bf 10 0c           write   stx     SAVE_PC
0962 35a8 bf 10 0e                   stx     ADDRESS
0963 35ab 16 01 3d                   lbra    done
0964                         
0965                         ; Handle EXG instruction.
0966                         ; Need to manually handle cases where source or destination is the PC
0967                         ; since it won't run correctly from the buffer.
0968                         
0969 35ae b6 10 12           tryexg  lda     OPCODE          ; Get the actual op code
0970 35b1 81 1e                      cmpa    #$1E            ; Is it EXG R1,R2 ?
0971 35b3 26 79                      bne     trypul          ; Branch if not
0972                         
0973 35b5 be 10 0e                   ldx     ADDRESS         ; Get address of instruction
0974 35b8 a6 01                      lda     1,x             ; Get operand byte
0975 35ba 84 f0                      anda    #%11110000      ; Mask source bits
0976 35bc 81 50                      cmpa    #%01010000      ; Is source register PC?
0977 35be 26 06                      bne     checkdest1      ; Branch if not
0978 35c0 a6 01                      lda     1,x             ; Get operand byte again
0979 35c2 84 0f                      anda    #%00001111      ; Mask destination bits
0980 35c4 20 16                      bra     doexg           ; Do the exchange
0981                         checkdest1
0982 35c6 a6 01                      lda     1,x             ; Get operand byte
0983 35c8 84 0f                      anda    #%00001111      ; Mask destination bits
0984 35ca 81 05                      cmpa    #%00000101      ; Is destination register PC?
0985 35cc 10 26 00 a1                lbne    norml           ; Branch and execute normally if not
0986 35d0 a6 01                      lda     1,x             ; Get operand byte again
0987 35d2 84 f0                      anda    #%11110000      ; Mask source bits
0988 35d4 04 00                      lsr                     ; Shift into low nybble
0989 35d6 04 00                      lsr
0990 35d8 04 00                      lsr
0991 35da 04 00                      lsr                     ; And fall thru to code below
0992                         
0993 35dc 10 be 10 0e        doexg   ldy     ADDRESS         ; Get current PC
0994 35e0 31 22                      leay    2,y             ; Add instruction length
0995                         
0996 35e2 81 00                      cmpa    #%00000000      ; Exchange D?
0997 35e4 27 13                      beq     exg_d
0998 35e6 81 01                      cmpa    #%00000001      ; Exchange X?
0999 35e8 27 19                      beq     exg_x
1000 35ea 81 02                      cmpa    #%00000010      ; Exchange Y?
1001 35ec 27 1d                      beq     exg_y
1002 35ee 81 03                      cmpa    #%00000011      ; Exchange U?
1003 35f0 27 21                      beq     exg_u
1004 35f2 81 04                      cmpa    #%00000100      ; Exchange S?
1005 35f4 27 25                      beq     exg_s
1006 35f6 16 00 e8                   lbra    update          ; Anything else is invalid or PC to PC, so ignore
1007                         
1008                         ; At this point Y contains PC
1009                         
1010                         exg_d                           ; Swap PC and D
1011 35f9 be 10 01                   ldx     SAVE_D
1012 35fc 1e 12                      exg     x,y
1013 35fe bf 10 01                   stx     SAVE_D
1014 3601 20 20                      bra     fin
1015 3603 be 10 04           exg_x   ldx     SAVE_X          ; Swap PC and X
1016 3606 1e 12                      exg     x,y
1017 3608 bf 10 04                   stx     SAVE_X
1018 360b be 10 06           exg_y   ldx     SAVE_Y          ; Swap PC and Y
1019 360e 1e 12                      exg     x,y
1020 3610 bf 10 06                   stx     SAVE_Y
1021 3613 be 10 08           exg_u   ldx     SAVE_U          ; Swap PC and U
1022 3616 1e 12                      exg     x,y
1023 3618 bf 10 08                   stx     SAVE_U
1024 361b be 10 0a           exg_s   ldx     SAVE_S          ; Swap PC and S
1025 361e 1e 12                      exg     x,y
1026 3620 bf 10 0a                   stx     SAVE_S
1027 3623 10 bf 10 0e        fin     sty     ADDRESS
1028 3627 10 bf 10 0c                sty     SAVE_PC
1029 362b 16 00 bd                   lbra    done
1030                         
1031                         ; Handle PULS/PULU PC,r,r,r
1032                         ; Could support it, but handling all the combinations of registers
1033                         ; would take a lot of code. For now, just generate warning that
1034                         ; instruction is unsupported and being ignored.
1035                         
1036 362e b6 10 12           trypul  lda     OPCODE          ; Get the actual op code
1037 3631 81 35                      cmpa    #$35            ; Is it PULS ?
1038 3633 27 04                      beq     pull            ; If so, handle it.
1039 3635 81 37                      cmpa    #$37            ; Is it PULU ?
1040 3637 26 18                      bne     trypush         ; If no, skip
1041                         
1042 3639 be 10 0e           pull    ldx     ADDRESS         ; Get address of instruction
1043 363c a6 01                      lda     1,x             ; Get operand byte
1044 363e 84 80                      anda    #%10000000      ; Mask PC bit
1045 3640 81 80                      cmpa    #%10000000      ; Is PC bit set?
1046 3642 26 2d                      bne     norml           ; If not, handle nornmally
1047                         
1048                         ; Display "Warning: instruction not supported, skipping."
1049                         
1050 3644 30 8d 01 5e                leax    MSG11,PCR       ; Message string
1051 3648 17 8a 52                   lbsr    PrintString     ; Display it
1052 364b 17 89 e0                   lbsr    PrintCR
1053 364e 16 00 90                   lbra    update          ; Don't execute it
1054                         
1055                         ; Handle PSHS/PSHU PC,r,r,r
1056                         ; Could support it, but handling all the combinations of registers
1057                         ; would take a lot of code. For now just generate warning that
1058                         ; instruction is unsupported and results will be incorrect.
1059                         ; Still execute the instruction.
1060                         
1061 3651 b6 10 12           trypush lda     OPCODE          ; Get the actual op code
1062 3654 81 34                      cmpa    #$34            ; Is it PSHS ?
1063 3656 27 04                      beq     push            ; If so, handle it.
1064 3658 81 36                      cmpa    #$36            ; Is it PSHU ?
1065 365a 26 15                      bne     norml           ; If no, skip
1066                         
1067 365c be 10 0e           push    ldx     ADDRESS         ; Get address of instruction
1068 365f a6 01                      lda     1,x             ; Get operand byte
1069 3661 84 80                      anda    #%10000000      ; Mask PC bit
1070 3663 81 80                      cmpa    #%10000000      ; Is PC bit set?
1071 3665 26 0a                      bne     norml           ; If not, handle nornmally
1072                         
1073                         ; Display "Warning: instruction not supported, expect incorrect results."
1074                         
1075 3667 30 8d 01 69                leax    MSG12,PCR       ; Message string
1076 366b 17 8a 2f                   lbsr    PrintString     ; Display it
1077 366e 17 89 bd                   lbsr    PrintCR
1078                                                         ; Fall through and execute it
1079                         
1080                         ; Otherwise:
1081                         ; Not a special instruction. We execute it from the buffer.
1082                         ; Copy instruction and operands to RAM buffer (based on LEN, can be 1 to 5 bytes)
1083                         ; TODO: Handle PC relative instructions.
1084                         
1085                         
1086                         ; Thoughts on handling PC relative modes:
1087                         ; Original code:
1088                         ; 2013  A6 8D 00 14                lda     tbl,pcr
1089                         ; 202B  01 02 03 04 05     tbl     fcb     1,2,3,4,5
1090                         ; Offset $0014 = $202B - ($2013 + 4)
1091                         ;
1092                         ; When running in buffer:
1093                         ; 101C  A6 8D 10 0B                lda     tbl,pcr
1094                         ; Offset should be $202B - ($101C + 4) = $100B
1095                         ; Change offset by $100B - $0014 = $0FF7
1096                         ; Original Address - Buffer Address = $2013 - $101C - $0FF7
1097                         ; Should be able to fix up offset to run in buffer.
1098                         ; Can't handle case where offset is 8 bits but won't reach buffer.
1099                         
1100                         
1101 3671 be 10 0e           norml   ldx     ADDRESS         ; Address of instruction
1102 3674 10 8e 10 1c                ldy     #BUFFER         ; Address of buffer
1103 3678 4f                         clra                    ; Loop counter and index
1104 3679 e6 86              copy    ldb     a,x             ; Get instruction byte
1105 367b e7 a6                      stb     a,y             ; Write to buffer
1106 367d 4c                         inca                    ; Increment counter
1107 367e b1 10 16                   cmpa    LENGTH          ; Copied all bytes?
1108 3681 26 f6                      bne     copy
1109                         
1110                         ; Add a jump after the instruction to where we want to go after it is executed (ReturnFromTrace).
1111                         
1112 3683 c6 7e                      ldb     #$7E            ; JMP $XXXX instruction
1113 3685 e7 a6                      stb     a,y             ; Store in buffer
1114 3687 4c                         inca                    ; Advance buffer
1115 3688 8e 36 b7                   ldx     #ReturnFromTrace ; Destination address of JMP
1116 368b af a6                      stx     a,y             ; Store in buffer
1117                         
1118                         ; Restore registers from saved values.
1119                         
1120 368d 10 ff 10 18                sts     OURS            ; Save this program's stack pointers
1121 3691 ff 10 1a                   stu     OURU
1122                         
1123 3694 f6 10 02                   ldb     SAVE_B
1124 3697 be 10 04                   ldx     SAVE_X
1125 369a 10 be 10 06                ldy     SAVE_Y
1126 369e 10 fe 10 0a                lds     SAVE_S
1127 36a2 fe 10 08                   ldu     SAVE_U
1128 36a5 b6 10 03                   lda     SAVE_DP
1129 36a8 1f 8b                      tfr     a,dp
1130 36aa b6 10 00                   lda     SAVE_CC
1131 36ad 36 02                      pshu    a
1132 36af b6 10 01                   lda     SAVE_A
1133 36b2 37 01                      pulu    cc              ; Has to be last so CC is left unchanged
1134                         
1135                         ; Call instruction in buffer. It is followed by a JMP ReturnFromTrace so we get back.
1136                         
1137 36b4 7e 10 1c                   jmp     BUFFER
1138                         
1139                         ReturnFromTrace
1140                         
1141                         ; Restore saved registers (except PC).
1142                         
1143 36b7 36 01                      pshu    cc              ; Have to save before it changes
1144 36b9 b7 10 01                   sta     SAVE_A
1145 36bc 37 02                      pulu    a
1146 36be b7 10 00                   sta     SAVE_CC
1147 36c1 1f b8                      tfr     dp,a
1148 36c3 b7 10 03                   sta     SAVE_DP
1149 36c6 f7 10 02                   stb     SAVE_B
1150 36c9 bf 10 04                   stx     SAVE_X
1151 36cc 10 bf 10 06                sty     SAVE_Y
1152 36d0 10 ff 10 0a                sts     SAVE_S
1153 36d4 ff 10 08                   stu     SAVE_U
1154                         
1155                         ; Restore this program's stack pointers so RTS etc. will still work.
1156                         
1157 36d7 10 fe 10 18                lds     OURS
1158 36db fe 10 1a                   ldu     OURU
1159                         
1160                         ; Set this program's DP register to zero just in case calling program changed it.
1161                         
1162 36de 4f                         clra
1163 36df 1f 8b                      tfr     a,dp
1164                         
1165                         ; Update new ADDRESS value based on instruction address and length
1166                         
1167 36e1 4f                 update  clra                    ; Set MSB to zero
1168 36e2 f6 10 16                   ldb     LENGTH          ; Get length byte
1169 36e5 f3 10 0e                   addd    ADDRESS         ; 16-bit add
1170 36e8 fd 10 0e                   std     ADDRESS         ; Store new address value
1171                         
1172                         ; And return.
1173                         
1174 36eb 39                 done    rts
1175                         
1176                         ;------------------------------------------------------------------------
1177                         ; Display register values
1178                         ; Uses values in SAVED_A etc.
1179                         ; e.g.
1180                         ; PC=FEED A=01 B=02 X=1234 Y=2345 S=2000 U=2000 DP=00 CC=10001101 (EFHINZVC)
1181                         
1182                         DisplayRegs
1183 36ec 30 8d 00 8c                leax    MSG1,PCR
1184 36f0 17 89 aa                   lbsr    PrintString
1185 36f3 be 10 0c                   ldx     SAVE_PC
1186 36f6 17 89 96                   lbsr    PrintAddress
1187                         
1188 36f9 30 8d 00 83                leax    MSG2,PCR
1189 36fd 17 89 9d                   lbsr    PrintString
1190 3700 b6 10 01                   lda     SAVE_A
1191 3703 17 89 7b                   lbsr    PrintByte
1192                         
1193 3706 30 8d 00 79                leax    MSG3,PCR
1194 370a 17 89 90                   lbsr    PrintString
1195 370d b6 10 02                   lda     SAVE_B
1196 3710 17 89 6e                   lbsr    PrintByte
1197                         
1198 3713 30 8d 00 6f                leax    MSG4,PCR
1199 3717 17 89 83                   lbsr    PrintString
1200 371a be 10 04                   ldx     SAVE_X
1201 371d 17 89 6f                   lbsr    PrintAddress
1202                         
1203 3720 30 8d 00 65                leax    MSG5,PCR
1204 3724 17 89 76                   lbsr    PrintString
1205 3727 be 10 06                   ldx     SAVE_Y
1206 372a 17 89 62                   lbsr    PrintAddress
1207                         
1208 372d 30 8d 00 5b                leax    MSG6,PCR
1209 3731 17 89 69                   lbsr    PrintString
1210 3734 be 10 0a                   ldx     SAVE_S
1211 3737 17 89 55                   lbsr    PrintAddress
1212                         
1213 373a 30 8d 00 51                leax    MSG7,PCR
1214 373e 17 89 5c                   lbsr    PrintString
1215 3741 be 10 08                   ldx     SAVE_U
1216 3744 17 89 48                   lbsr    PrintAddress
1217                         
1218 3747 30 8d 00 47                leax    MSG8,PCR
1219 374b 17 89 4f                   lbsr    PrintString
1220 374e b6 10 03                   lda     SAVE_DP
1221 3751 17 89 2d                   lbsr    PrintByte
1222                         
1223 3754 30 8d 00 3e                leax    MSG9,PCR        ; Show CC in binary
1224 3758 17 89 42                   lbsr    PrintString
1225 375b 8e 00 08                   ldx     #8              ; Loop counter
1226 375e f6 10 00                   ldb     SAVE_CC         ; Get CC byte
1227 3761 58                 ploop   aslb                    ; Shift bit into carry
1228 3762 25 04                      bcs     one             ; Branch if it is a one
1229 3764 86 30                      lda     #'0'            ; Print '0'
1230 3766 20 02                      bra     prn
1231 3768 86 31              one     lda     #'1'            ; Print '1'
1232 376a bd c0 7b           prn     jsr     PrintChar
1233 376d 30 1f                      leax    -1,x            ; Decrement loop counter
1234 376f 26 f0                      bne     ploop           ; Branch if not done
1235                         
1236 3771 30 8d 00 25                leax    MSG10,PCR
1237 3775 17 89 25                   lbsr    PrintString
1238 3778 17 88 b3                   lbsr    PrintCR
1239 377b 39                         rts
1240                         
1241 377c 50 43 3d           MSG1    FCC     "PC="
1242 377f 04                         FCB     EOT
1243 3780 41 3d              MSG2    FCC     "A="
1244 3782 04                         FCB     EOT
1245 3783 42 3d              MSG3    FCC     "B="
1246 3785 04                         FCB     EOT
1247 3786 58 3d              MSG4    FCC     "X="
1248 3788 04                         FCB     EOT
1249 3789 59 3d              MSG5    FCC     "Y="
1250 378b 04                         FCB     EOT
1251 378c 53 3d              MSG6    FCC     "S="
1252 378e 04                         FCB     EOT
1253 378f 55 3d              MSG7    FCC     "U="
1254 3791 04                         FCB     EOT
1255 3792 44 50 3d           MSG8    FCC     "DP="
1256 3795 04                         FCB     EOT
1257 3796 43 43 3d           MSG9    FCC     "CC="
1258 3799 04                         FCB     EOT
1259 379a 20 28 45 46 48 49  MSG10   FCC     " (EFHINZVC)"
     4e 5a 56 43 29
1260 37a5 04                         FCB     EOT
1261 37a6 57 61 72 6e 69 6e  MSG11   FCC     "Warning: instruction not supported, skipping."
     67 3a 20 69 6e 73
     74 72 75 63 74 69
     6f 6e 20 6e 6f 74
     20 73 75 70 70 6f
     72 74 65 64 2c 20
     73 6b 69 70 70 69
     6e 67 2e
1262 37d3 04                         FCB     EOT
1263 37d4 57 61 72 6e 69 6e  MSG12   FCC     "Warning: instruction not supported, expect incorrect results."
     67 3a 20 69 6e 73
     74 72 75 63 74 69
     6f 6e 20 6e 6f 74
     20 73 75 70 70 6f
     72 74 65 64 2c 20
     65 78 70 65 63 74
     20 69 6e 63 6f 72
     72 65 63 74 20 72
     65 73 75 6c 74 73
     2e
1264 3811 04                         FCB     EOT
1265                         
1266                         ;------------------------------------------------------------------------
1267                         ; Disassemble an instruction. Uses ASSIST09 ROM code.
1268                         ; e.g. 
1269                         ; 1053 2001 86 01    lda     #$01
1270                         
1271                         Disassemble
1272 3812 be 10 0c                   ldx     SAVE_PC         ; Get address of instruction
1273 3815 bf 5f f0                   stx     ADRS            ; Pass it to the disassembler
1274 3818 bd c0 a4                   jsr     DISASM          ; Disassemble one instruction
1275 381b 39                         rts
1276                         
1277                         ; ASSIST09 SWI call numbers
1278                         
1279 0009                    A_VCTRSW equ    9               ; Vector swap
1280 0032                    .ECHO   equ     50              ; Secondary command list
1281                         
1282                         ;------------------------------------------------------------------------
1283                         ; Turn off echo when calling keyboard input routines.
1284                         
1285 381c 34 12              EchoOff pshs    a,x             ; Save registers
1286 381e 8e ff ff                   ldx     #$FFFF          ; New echo value (off)
1287 3821 86 32                      lda     #.ECHO          ; Load subcode for vector swap
1288 3823 3f                         swi                     ; Request service
1289 3824 09                         fcb     A_VCTRSW        ; Service code byte
1290 3825 35 12                      puls    a,x             ; Save registers
1291 3827 39                         rts                     ; Return to monitor
